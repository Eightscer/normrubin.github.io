[
  {
    "objectID": "lectures/02a_performance_measurement.html",
    "href": "lectures/02a_performance_measurement.html",
    "title": "2a Performance and Measurement",
    "section": "",
    "text": "Measurement\n#example 1\nProducing Wrong Data Without Doing Anything Obviously Wrong! Todd Mytkowicz, Amer Diwan, Matthias Hauswirth, and Peter F. Sweeney. ASPLOS 2009.\n445 references\nclaim 1 measurement bias is commonplace and significant\nConsider a researcher who wants to determine if optimization O is beneficial for system S. If she measures S and S + O in an experimental setup that favors S + O, she may overstate the effect of O or even conclude that O is beneficial even when it is not. This phenomenon is called measurement bias in the natural and social sciences.\nAre O3 optimizations are beneficial to program performance when the experimental setups differ. Specifically, we consider experimental setups that differ along two dimensions: (i) UNIX environment size (i.e., total number of bytes required to store the environment variables) because it affects the alignment of stack allocated data; and (ii) link order (the order of .o files that we give to the linker) because it affects code and data layout.\ntests all C benchmarks from spec benchmark 9 int and 3 float ran each 5940 times over 12 days ran on real hardware used gcc\ntest link order -8% to +10% speedup based on link order same results on simulator\ntest environment size -10% to +10 percent speedup\nran some of the tests using intel c compiler to show its not gcc specific.\nClaim 2 researchers need to consider measurement bias\nNone of the papers in APLOS 2008, PACT 2007, PLDI 2007, and CGO 2007 address measurement bias satisfactorily.\nOf the 133 papers published in the surveyed conference proceedings, 88 had at least one section dedicated to experimental methodology and evaluation. The median speedup reported by these papers was 10%.\n#example 2\nStrangely, Matrix Multiplications on GPUs Run Faster When Given “Predictable” Data!\nSIGPLAN Empirical Evaluation Guidelines\n\n\n\n\n Back to top",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "2a Performance and Measurement"
    ]
  },
  {
    "objectID": "lectures/04_data_flow.html",
    "href": "lectures/04_data_flow.html",
    "title": "4. Data Flow",
    "section": "",
    "text": "We will see a single algorithm that can do lots of different analysis. And it works no matter what kind of control flow.\nThere is some theory to look at for this. How do we know if the algorithm will converge for any possible cfg.\nand some naming for each kind of problem\n\n\n\n\n\ngraph TD\nstyle A text-align: left\nstyle B  text-align: left\n%% nodes \n     A[\"1: main cond\n   2: a int = const 47\n   3: b :int = const 42\n   4:br cond .left .right\"] \n   \n   B[\"5: b: int = const 1\n   6 c:int = const 5 \n   7 jmp .end\"]\n  \n   C[\"8: a :int = const 2\n   9: c: int = const 10\n   10 jmp .end\"]\n    D[\"11: d: int sub  a b\n    12 print d\n    13 ret\"]\n%% edges\n    A  -- true --&gt; B\n    A  --false --&gt; C\n    B --&gt; D\n    C --&gt; D",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "4. Data Flow"
    ]
  },
  {
    "objectID": "lectures/04_data_flow.html#reasoning-about-data-flow-global-analysis",
    "href": "lectures/04_data_flow.html#reasoning-about-data-flow-global-analysis",
    "title": "4. Data Flow",
    "section": "",
    "text": "We will see a single algorithm that can do lots of different analysis. And it works no matter what kind of control flow.\nThere is some theory to look at for this. How do we know if the algorithm will converge for any possible cfg.\nand some naming for each kind of problem\n\n\n\n\n\ngraph TD\nstyle A text-align: left\nstyle B  text-align: left\n%% nodes \n     A[\"1: main cond\n   2: a int = const 47\n   3: b :int = const 42\n   4:br cond .left .right\"] \n   \n   B[\"5: b: int = const 1\n   6 c:int = const 5 \n   7 jmp .end\"]\n  \n   C[\"8: a :int = const 2\n   9: c: int = const 10\n   10 jmp .end\"]\n    D[\"11: d: int sub  a b\n    12 print d\n    13 ret\"]\n%% edges\n    A  -- true --&gt; B\n    A  --false --&gt; C\n    B --&gt; D\n    C --&gt; D",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "4. Data Flow"
    ]
  },
  {
    "objectID": "lectures/04_data_flow.html#first-we-are-going-to-look-at-a-fg-specific-problem-reaching-definitions",
    "href": "lectures/04_data_flow.html#first-we-are-going-to-look-at-a-fg-specific-problem-reaching-definitions",
    "title": "4. Data Flow",
    "section": "first we are going to look at a fg specific problem “reaching definitions”",
    "text": "first we are going to look at a fg specific problem “reaching definitions”\nReaching definitions are an example of a global property that require you to look at an entire CFG.\nUse: An instruction uses all of its arguments. (So any instruction with arguments is a “use.”), a binary instruction is two uses.\nA definition is place in the program that assigns a value to an instruction. For Bril, a definition is a value instruction (has a dest or an argument)\nThe above program has 8 definitions, Which we could represent by a bit vector of size 8.\nA definition D reaches a point P (instruction) in the program if there is an execution path from D to P, and the variable in D is not overwritten on the path.\nAvailable: Definitions that reach a given point in the program are available at that point.\nif an instruction writes a variable it kills all prior definitions that write the same variable\n\nReaching definitions problem determine which definitions reach which uses.\nWe could build a 2d matrix - definitions by uses, where a 1 bit indicates that this definition reaches this use. As a matrix this would be very sparse, later when we do ssa forms will see a very cool compression technique. Algorithms that use this kind of matrix are called bit-vector methods.\nA program point is an instruction\na definition of a variable v reaches a program point p if and only if:\n\nthe definition reaches the point just before p\nthe variable v is not redefined at p\n\nor\n\nthe variable v is defined at p.\n\nWhat about multiple predecessors? p is the first instruction of a block with multiple preds.\nIf a definition reaches a point immediately after at least one pred of p then it reaches the point immediately before p. This is a union operation.\nWe are moving information down from definition. This is called forward propagation\nDefine two sets IN and OUT that hold definitions\nIN is the set of definitions that reach a point immediately before p\nOUT is the set of definitions that reach a point immediately after p\nTo illustrate this, I”ll use pairs (variable, def) for each set, but the def already includes the variable so real implementations can just use the def.\n\n\n\n\n\ngraph TD\nstyle A text-align: left\nstyle B  text-align: left\n%% nodes \nA_IN[\"A_IN={}\"]\nA_OUT[\"A_OUT={(cond,1),(a,2),(b,3)}\"]\n\nB_IN[\"B_IN={(cond,1),(a,2),(b,3)}\"]\nB_OUT[\"B_OUT={(cond,1),(a,2),(b,5),(c,6)}\"]\n\nC_IN[\"IN={(cond,1),(a,2),(b,3)}\"]\nC_OUT[\"OUT={(cond,1),(a,8),(b,3,(c,9)}\"]\n\nD_IN[\"IN={(cond,1),(a,2),(a,8) (b,5), (b,3), (c,6), (c,9)}\"]\n\n  A[\"blk a\n    1: main cond\n   2: a int = const 47\n   3: b :int = const 42\n   4:br cond .left .right\"] \n   \n   B[\"blk b\n   5: b: int = const 1\n   6 c:int = const 5 \n   7 jmp .end\"]\n  \n   C[\"blk c\n     8: a :int = const 2\n   9: c: int = const 10\n   10 jmp .end\"]\n    D[\"11: d: int sub  a b\n    12 print d\n    13 ret\"]\n%% edges\n    A_IN --&gt; A \n    A --&gt; A_OUT\n    A_OUT  -- true --&gt; B_IN\n    B_IN --&gt; B\n    B --&gt; B_OUT\n    A_OUT --false --&gt; C_IN\n    C_IN --&gt; C\n    C--&gt;   C_OUT\n    B_OUT--&gt; D_IN\n    C_OUT--&gt; D_IN\n    D_IN --&gt; D\n\n\n\n\n\n\nFor a given block b, we can compute two sets:\n\nkill(b) = all defs in the program that assign to y, and there is a def of y in b\n\ngen(b) = definitions in b that reach the bottom of b\n\nAnd now globally:\n\nOUT(b) = (in(b) - kill(b) ) union gen(b)\nIN(b) = union of OUT(pred) where pred is a predecessor of b\n\nWe call the function for 1 the transfer function for the block, and the function for 2 the merge function\nWe can solve for IN and OUT iteratively using a worklist\n// Initialize\nfor all CFG nodes n in N,\n    OUT[n] = emptyset; // can optimize by OUT[n] = GEN[n];\n\n// put all nodes into the changed set\n// N is all nodes in graph,\nChanged = N;\n\n// Iterate \nwhile (Changed != emptyset)\n{\n    choose a node n in Changed;\n    // remove it from the changed set\n    Changed = Changed -{ n };\n\n    // init IN[n] to be empty\n    IN[n] = emptyset;\n  \n    // calculate IN[n] from predecessors' OUT[p]\n    for all nodes p in predecessors(n)\n         IN[n] = IN[n] Union OUT[p];\n\n    oldout = OUT[n]; // save old OUT[n]\n    \n    // update OUT[n] using transfer function f_n ()\n    OUT[n] = GEN[n] Union (IN[n] -KILL[n]);\n\n    // any change to OUT[n] compared to previous value?\n    if (OUT[n] changed) // compare oldout vs. OUT[n]\n    {    \n        // if yes, put all successors of n into the changed set\n        for all nodes s in successors(n)\n             Changed = Changed U { s };\n    }\n}\n\nDoes this always converge?\nwhat order do we want to select nodes (basic blocks)?\nvisit a node after visiting its preds. Revese post order.\n\n\na second problem liveness-\nA variable is live at some point if it holds a value that may be needed in the future, or equivalently if its value may be read before the next time the variable is written to.\n             live = {}\nb = 3        live = b\nc = 5        live = b c \na = f(b * c) live = a\nWe had to consider flow starting at the bottom so this is a backwards analysis\nfor a basic block (b):\n\nGEN(s) the set of variables used in s before any assignment to s in the same block\nkill(s) the set of variables assigned in s\n\nglobal\n\nOUT(exit) = {}\nIN(b) = gen(b) union ( OUT(b) - KILL(b))\nOUT(b) = union IN(b)\n\nAn example\n// in: {}; predecessor blocks: none\nb1: a = 3; \n    b = 5;\n    d = 4;\n    x = 100; //x is never being used later thus not in the out set {a,b,d}\n    t = a &gt; b\n    br t .t .f \n   // out: {a,b,d}    //union of all (in) successors of b1 =&gt; b2: {a,b}, and b3:{b,d}  \n\n\n\n.t   // in: {a,b}; predecessor blocks: b1\nb2: c = a + b;\n    d = 2;\n// out: {b,d}\n\n\n.f \nb3:  in: {b,d}; predecessor blocks: b1 and b2\n    c = 4;\n    return b * d + c;\n// out:{}\nThis can be solved using the same code as before, flip pred, successors because its backward, reverse in and out, set elements are variable names\ndata flow framework\nThe data flow framework. Here’s how you solve a global analysis problem by imbuing a local analysis with a dose of data-flow magic:\n\nFigure out the thing you want to know at the entry and exit of each block.\nWrite an equation for every block relating that thing at the entry to that thing at the exit. (In general, this is a local analysis for the block.), calculate GEN and KILL\nGenerate equalities according to the edges in the CFG.\nSolve the system of equations! (Using a general solver algorithm that you don’t need to adapt to every problem.)\n\nstep 2 only looks at a single block, the iteration does not need to refigure out GEN and KILL\nThis algorithm has no problems with loops!\nTheory – the requirements for a general data flow analysis. How do you know the worklist algorithm terminates and gives you the right answer?\nThe domain of values you’re trying compute needs to form a partial order with a unique lower bound. The rough idea is that the worklist algorithm should only “move” values monotonically in the order, so it’s guaranteed to eventually terminate.\nIn terms of a partial order ⊑, the merge function is the meet (greatest lower bound) operator ⊓; the initial value is the top value ⊤; and the transfer function must be a monotonic function, so x ⊑ y implies f(x) ⊑ f(y).\nThe usual definition of a “correct” solution to a data-flow problem is the meet-over-all-paths solution: the meet of chained applications of the transfer functions for every path in the CFG from the entry block to any given block\nMore examples of things you can do with the data flow framework. 1) Reaching definitions. 1) Live variables: which variables are both defined and going to be used at some point in the future? 1) Constant propagation: which variables have statically knowable constant values? 1) Available expressions: which expressions have already been computed computed in the past? (Useful in CSE.) 1) Initialized variables: like in Java, which variables have had something written to them? 1) Interval analysis: what is the numerical range of values that a given variable might hold?",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "4. Data Flow"
    ]
  },
  {
    "objectID": "lectures/03_local.html",
    "href": "lectures/03_local.html",
    "title": "3a Local Analysis & Optimization",
    "section": "",
    "text": "I want to separate 3 flavors of optimization.\nUsually an optimization takes time that is more then linear in some property, For example a local optimization might take time \\(n^2\\) in the number of instructions in the block. a global optimization might take much longer, and an inter-procedural longer still. To keep compile time reasonable many compilers limit the number of global optimizations and skip inter-procedural optimizations. As a consequence many more optimizations get published but not used in production.\nFor a local optimization, instructions within a block are ordered, so it makes sense to talk about instructions coming before or after others.\nFor a global optimization, two instructions are ordered by a path from one block to another and different paths through the program give different orders.\nOne special case is JIT (just in time) compilers, where programs get compiled at the start of execution. GPU compilers (and java compilers) look like this. They may use run-time information to decide of recompiling a function is a good idea. This is called Hotspot compiling. Some JIT compilers use hot/cold compiling, where they only run the fancy compiler on basic blocks that are hotl, i.e., execute a lot.\nflowchart LR\nA[application] -- offline --&gt; B[byte code/ptx]\nB --&gt; C[quick run time compiler/ finalizer]\nC --&gt; D[isa]\nB --&gt; C1[fancy compiler - only run on long running functions];\nC1 --&gt; D;\nWe are going to consider several versions of trivial dead code elimination. Trivial because we are going to hold off on control flow related optimizations till later. Sometimes people call this DCE or trivial DCE.\nFor each case, we start by defining what we mean by dead code.\nexample 1\nWhat instruction is dead? (meaning get the same answer if we delete the instruction) What is your definition? Is this meaning of dead code local or global?\nWhy would you ever have dead code in a program? One reason is that have DCE as a separate pass means other optimizations do not have to clean up.",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "3a Local Analysis & Optimization"
    ]
  },
  {
    "objectID": "lectures/03_local.html#definition-1--dead-if-instruction-writes-a-variable-and-the-variable-is-never-used.",
    "href": "lectures/03_local.html#definition-1--dead-if-instruction-writes-a-variable-and-the-variable-is-never-used.",
    "title": "3a Local Analysis & Optimization",
    "section": "Definition 1- Dead if instruction writes a variable and the variable is never used.",
    "text": "Definition 1- Dead if instruction writes a variable and the variable is never used.\nAn instruction that has side-effects, like a print statement does not write a variable so it never gets deleted. Labels no not write a variable so they get deleted as well.\nWhat is the pseudo code to find dead instructions using this definition?\nused = empty set \nfor instr in func \n   used += instr.args \nfor instd in func\n    if instr has a dest and dest in not in used \n       delete instr\nexample 2\n@main {\n  a: int = const 4;\n  b: int = const 2;\n  c: int = const 1;  \n  d: int = add a b;\n  e: int = add c d; \n  print d;\n}\nThe code so far only deletes one instruction, but we would like to get rid of two. Instruction c should also be dead. How do we change the definition",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "3a Local Analysis & Optimization"
    ]
  },
  {
    "objectID": "lectures/03_local.html#definition-2--dead-if-instruction-writes-a-variable-and-the-variable-is-either-never-used-or-only-used-in-dead-instructions.",
    "href": "lectures/03_local.html#definition-2--dead-if-instruction-writes-a-variable-and-the-variable-is-either-never-used-or-only-used-in-dead-instructions.",
    "title": "3a Local Analysis & Optimization",
    "section": "Definition 2- Dead if instruction writes a variable and the variable is either never used or only used in dead instructions.",
    "text": "Definition 2- Dead if instruction writes a variable and the variable is either never used or only used in dead instructions.\nA slow way to do this. - iterating till convergence\nwhile changes:\n       run one pass of tdce above\nwhat would be faster? What is some pseudo code for the change\nexample 3\n@main {\n  a: int = const 4;\n  a: int = const 200;\n  print a;\n}",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "3a Local Analysis & Optimization"
    ]
  },
  {
    "objectID": "lectures/03_local.html#definition-an-instruction-is-dead-if-that-instruction-writes-a-variable-v-and-no-path-starting-at-that-instruction-reaches-a-use-of-v",
    "href": "lectures/03_local.html#definition-an-instruction-is-dead-if-that-instruction-writes-a-variable-v-and-no-path-starting-at-that-instruction-reaches-a-use-of-v",
    "title": "3a Local Analysis & Optimization",
    "section": "Definition? An instruction is dead if that instruction writes a variable v and no path starting at that instruction reaches a use of v",
    "text": "Definition? An instruction is dead if that instruction writes a variable v and no path starting at that instruction reaches a use of v\nthis talks about paths (control flow paths)\n@main {\n  a: int = const 4;\n     br input .then .else \n  .then\n  a: int = const 200;\n  .else \n  print a;\n}\nfor now we want to skip control flow, so we",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "3a Local Analysis & Optimization"
    ]
  },
  {
    "objectID": "lectures/03_local.html#definition-an-instruction-is-dead-if-that-instruction-writes-a-variable-v-and-no-path-within-the-block-starting-at-that-instruction-reaches-a-use-of-v-in-the-same-block-or-reaches-the-exit-of-the-block",
    "href": "lectures/03_local.html#definition-an-instruction-is-dead-if-that-instruction-writes-a-variable-v-and-no-path-within-the-block-starting-at-that-instruction-reaches-a-use-of-v-in-the-same-block-or-reaches-the-exit-of-the-block",
    "title": "3a Local Analysis & Optimization",
    "section": "Definition: An instruction is dead if that instruction writes a variable v and no path within the block starting at that instruction reaches a use of v in the same block or reaches the exit of the block",
    "text": "Definition: An instruction is dead if that instruction writes a variable v and no path within the block starting at that instruction reaches a use of v in the same block or reaches the exit of the block\ncands are the variables that are defined but not used \nlast_def = {}  variables -&gt; instructions \nthis is a mapping variables that have been defined but not used\n\n   for instr in block:\n      each arg (use) removes arg from last def \n      if the instr has a dest \n          if the dest is in last_def, \n      add dest-&gt;instr to last def\n  \nand as you might expect, we need to interate this till convergence\nDoes running dce make compilation time go up?\nCompilers often run dce more then once- why?\ntesting out dce\n\nprogram should get the same answer\nprogram should run less instructions\n\nSome test cases:\n\nsimple.bril,\nreassign.bril,\nother examples in the DCE test directory\n\nbril2json &lt; bench.bril | python3 tdce.py | bril2txt\nNext, try using wc to check static code size differences:\nbril2json &lt; bench.bril | wc -l\nbril2json &lt; bench.bril | python3 tdce.py | wc -l\nThen profiling to measure dynamic instruction count: The bril interpreter has a flag -p which prints the number of dynamcially executed instructions. How good a measure is this for real programs?\nbril2json &lt; bench.bril | brili -p\n\nbril2json &lt; bench.bril | python3 tdce.py | brili -p\nname = “slides from Phil Gibbons at CMU” url = “http://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L3-Local-Opts.pdf” details = “for more details and context on LVN",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "3a Local Analysis & Optimization"
    ]
  },
  {
    "objectID": "lectures/06_ssa.html",
    "href": "lectures/06_ssa.html",
    "title": "6 Static single assignment",
    "section": "",
    "text": "A variable in a program can have multiple definitions. In Bril definitions are instructions which compute values. Up till now we have been thinking about analysis which look at variables (names) but a different way to look at this is based on values, If we think of instructions calculating values, and uses being uses of values we can picture a graph called the data flow graph showing how values move through a program\nin SSA we change our IR so that every variable has exactly one definition in the program (each variable is assigned only once). The name SSA is statically there is only a single assignment per variable.\n\n\nIn addition to a language form, SSA is also a philosophy! It can fundamentally change the way you think about programs. In the SSA philosophy:\n\ndefinitions == variables\ninstructions == values\narguments == data flow graph edges\n\nIn LLVM, for example, instructions do not refer to argument variables by name—an argument is a pointer to defining instruction.\nStatic means in the text, not in the execution.\n\n\n\n\n\ngraph TD\nB0[\"0: i = 0\n    1: s = 0\"]\nB1[\"2: x = m\n    3: s = s + x\n    4: i = i +4\n    5: if i &lt; n go to B0\"]\nB0 --&gt; B1\nB1 --&gt; B1\n\n\n\n\n\n\nvariable i has two static assignments 1 and 4, so this program is not in SSA\nVariable s has two static assignments, x has one static assignment but x has lots of dynamic assignments (when the program executes)\nWe call a program without branches a piece of *** straightline code***.\n    @main {\n      a: int = const 4;\n      b: int = const 2;\n      a: int = add a b;\n      b: int = add a b;\n      print b;\n    }\nIts easy to see how to convert straight line code into ssa\n    @main {\n      a.1: int = const 4;\n      b.1: int = const 2;\n      a.2: int = add a.1 b.1;\n      b.2: int = add a.2 b.1;\n      print b.2;\n    }\nfor each variable a: \n    Count[a] = 0 \n    Stack[a] = [0]\n\nrename_basic_block(B): \n    for each instruction S in block B: \n        for each use of a variable x in S: \n            i = top(Stack[x]) \n            replace the use of x with xi for each variable a that S defines count[a] = Count[a] + 1 \n            i = Count[a]             \n            push i onto Stack[a]             \n            replace definition of a with ai \nWe don’t need the stack here but we will need it later.\nOf course, things will get a little more complicated when there is control flow. And because real machines are not SSA, using separate variables (i.e., memory locations and registers) for everything is bound to be inefficient.\nThe idea in SSA is to convert general programs into SSA form, do all our optimization there, and then convert back to a standard mutating form before we generate backend code.\n\n\n\nJust renaming assignments willy-nilly will quickly run into problems. Consider this program:\n\n\n\n\n\ngraph TB\nB0[\".b0\n    a: int = const 47;\n    br cond .left .right;\"]\nleft[\"a: int = add a a;\n    jmp .exit;\"]\nright[\"a: int = mul a a;\n        jmp .exit;\"]\nexit[\"print a;\"]\nB0 --&gt; left\nB0 --&gt; right\nleft --&gt; exit\nright --&gt; exit\n\n\n\n\n\n\nIf we start renaming all the occurrences of a, everything goes fine until we try to write that last print a. Which “version” of a should it use?\nTo match the expressiveness of unrestricted programs, SSA adds a new kind of instruction: a ϕ-node. ϕ-nodes are flow-sensitive copy instructions: they get a value from one of several variables, depending on which incoming CFG edge was most recently taken to get to them.\nIn Bril, a ϕ-node appears as a phi instruction:\na.4: int = phi .left a.2 .right a.3;\nThe phi instruction chooses between any number of variables, and it picks between them based on labels. If the program most recently executed a basic block with the given label, then the phi instruction takes its value from the corresponding variable.\nYou can write the above program in SSA like this:\n    @main(cond: bool) {\n    .entry:\n        a.1: int = const 47;\n        br cond .left .right;\n    .left:\n        a.2: int = add a.1 a.1;\n        jmp .exit;\n    .right:\n        a.3: int = mul a.1 a.1;\n        jmp .exit;\n    .exit:\n        a.4: int = phi .left a.2 .right a.3;\n        print a.4;\n    }\n\n\n\nBril has an SSA extension It adds support for a phi instruction. Beyond that, SSA form is just a restriction on the normal expressiveness of Bril—if you solemnly promise never to assign statically to the same variable twice, you are writing “SSA Bril.”\nThe reference interpreter has built-in support for phi, so you can execute your SSA-form Bril programs without fuss.\n\n\n\nCompilers that use the SSA form usually contain a step, before the generation of actual assembly code, in which phi functions are replaced by ordinary instructions. Normally these instructions are simple copies.\n\n\n\n\n\ngraph TD;\nsubgraph a;\n A0[\"io =\n     j0 = \n     k0 =\"]\nA1[\"i1 =\n   j1 =\n   k1 = \"]\nA2[\"i2 = phi(i0, i1\n   j2 = phi(j0, j1)\n   k2 = phi(k0, k1)\n   ...\n    = i2\n    = j2 \n    = k2\"]\n    A0 --&gt; A2\n    A1--&gt; A2\n end\nsubgraph b;\n B0[\"io =\n     j0 = \n     k0 =\"]\nB1[\"i1 =\n   j1 =\n   k1 = \"]\nB2[\"\n   ...\n    = i2\n    = j2 \n    = k2\"]\n    B0 --\"i2 = i0\n       j2 = j0\n       k2 = k0\"--&gt; B2\n    B1 --\"i2 = i1\n          j2 = j1\n          k2 = k1\"--&gt; B2\nend\n\n\n\n\n\n\n\n\n\n\n\n\ngraph TB\nA0[\"L1\n   a0 =\n   b0 =\n   if A0 &gt; b0\"]\nA1[\"b1 = a0\"]\nA2[\"l2\nb2 = phi(b1,b0)\"]\nA0 --&gt; A1\nA1--&gt; A2\nA0 --&gt; A2\n\n\n\n\n\n\nwhere do we put the copy b2 = b0?\nThe placement of the copy b2 = b0 is not simple, because the edge that links L2 to L5 is critical. A critical edge connects a block with multiple successors to a block with multiple predecessors.\nWe can solve this problem by doing critical edge splitting. This CFG transformation consists in adding an empty basic block (empty, except by – perhaps – a goto statement) between each pair of blocks connected by a critical edge.\n\n\nVery simple scheme\n\n\n\n\n\ngraph TB\nX[\"Block X\n   a = \n   b = \n   if s &gt; b\"]\nY[\"Block Y\n  b = a\"]\nZ[\"Block Z\nret b\"]\nX--&gt; Y\nY--&gt; Z\nX --&gt; Z\n\n\n\n\n\n\nThere should be a phi-function for variable b at node z of the flow graph exactly when all of the following are true:\n\nThere is a block x containing a definition of b\nThere is a block y (with y ≠ x) containing a definition of b\nThere is a nonempty path Pxz of edges from x to z\nThere is a nonempty path Pyz of edges from y to z\nPaths Pxz and Pyz do not have any node in common other than z, and…\nThe node z does not appear within both Pxz and Pyz prior to the end, though it may appear in one or the other.\n\nthis is iterative since when we add a phi, we are creating a new defintion, which may add new phi-functions\nWhen we find nodes X,Y,Z that match these steps and z does not contain a phi function for b, insert a phi\nWhile really expensive this will work\nTo convert to SSA, we want to insert ϕ-nodes whenever there are distinct paths containing distinct definitions of a variable. We don’t need ϕ-nodes in places that are dominated by a definition of the variable. So what’s a way to know when control reachable from a definition is not dominated by that definition? The dominance frontier!\nThis is going to be almost linear\nWe do it in two steps. 1) insert ϕ-nodes: 1) rename variables:\n\n\n\n\n\ngraph TB\n\na--&gt;b\na--&gt; e\na--&gt; i\n\nb--&gt;c\nc--- c\nc--&gt; d\ne--&gt; f[\"f\n  x = \"]\ne--&gt; g\ng--&gt; h\nf--&gt; h\nh--&gt;l\nf--&gt; d\nh--&gt; e\ni--&gt; k\ni--&gt; j\nj--&gt; k\nk--&gt; l\nd--&gt; l\n\n\n\n\n\n\n\nWe need phi functions for x in d and h, where else?\nwe need to iterate and keep adding phi nodes\nfor each node in the cfg \n   for each variable with a def in node\n     add node to Defs[v]   # Blocks where v is assigned.\n\nfor each v in vars:\n    W = Defs[v]\n    while W is not empty\n      remove a node n from w\n         for block in DF[d]:  # Dominance frontier.\n           Add a ϕ-node to block,\n             unless we have done so already.\n           Add block to W (because it now writes to v!),\n             unless it's already in there.\nSince we keep adding nodes to W how do we know this terminates?\nThen, rename variables:\nrename(n):\n  rename_basic_block(n)  # from before \n  for each successor Y of n, where n is the jth pred of Y\n    for each phi-function f in Y where the operand of f is 'a'\n      i = top(stack[a])\n      replace jth operand wit a_i\n  for each child of X of n (in the dominator tree)\n    rename(X)\n    for each instruction S in n\n       pop stack(S.dest)\n\n   \nThe arity of phi-functions\nCould we have a phi-function in a node with only one predecessor?\ncould we have a phi-function wit more then two arguments?\n\nThis algorithm computes what is called minimal SSA form which is not so mimimal since it can leave dead assignments\n\ni is only live in blocks l2 and l4 so no need to add phi-node at l1, this gives us pruned ssa form\n\n\n\n\nOur previous analyses always used a (variable, program point), but in ssa these are the same\n\n\n\nwhile there is some variable v with no uses and the statement that defines v has no other side effects, delete the statement that defines v from the program.\nwe need a counter for each variable (or each instruction)\nwalk the program once increment the counter each time the variable is used\nwhile there exists v, such that counter[v] = 0 remove the instruction that defined v, e.g., “v = E for each variable x used in E decrement counter[x]\n\n\n\nwe define a partial order on consts, any &gt; all constants &gt; undefined and define the intersection of two states as the common parent\nwith each variable we have an abstract state (like a value number)\nv  = const c   ==&gt; v state is const \n\nv = id q      ==&gt; v state is the state of  q \n\nv = v0 op v1  ==&gt; if both are constants v = c0 op c1\n\n             ==&gt; if one is any, v's state is &gt; \n\nv = phi(v0,..vn) ==&gt; v's state is the intersection of the states of v0,..,vn\nWhat order do we process nodes? because the program is in ssa form we can do the nodes in dominator tree order, then before processing any instruction that is not a phi, we will have processed all the arguments\nB0: x  = input \n    a = 1 \n    c = a +10\n    if a &lt; c go to b1\n\nB1: b = x * a\n    print b \n    a = a +1 \n    go to b1\n\nin ssa form \n\nB0: x0  = input \n    a0 = 1 \n    c0 = a0 +10\n    if a0 &lt; c0 go to b1\n\nB1: a1 phi(a1,a2 )\n    b0 = x0 * a1\n    print b0 \n    a2 = a1 +1 \n    go to b1\n\nwalking the dominator tree b0 -&gt; b1\nB0:\nx0 - any \na0 - 1 \nc0 - 11 (folding the constant)\na0 &lt; c0  skip\nB1:\na1 = 1 (only one input of phi is defined)\nb0 = any\na2 = 2\n\nupdate the uses of a2 - which is the phi a1 -&gt; any\nupdate the uses of a1 which is the increment no change \n\n\n\n## liveness \n\n![](images/StaticSingleAssignment_Part69.jpg)\n\n![](images/StaticSingleAssignment_Part70.jpg)\n\n![](images/StaticSingleAssignment_Part71.jpg)\n\n\n![](images/StaticSingleAssignment_Part73.jpg)\n\n\n\n\n### Converting from SSA\n\nEventually, we need to convert *out of* SSA form to generate efficient code for real machines that don't have `phi`-nodes and do have finite space for variable storage.\n\nThe basic algorithm is pretty straightforward.\nIf you have a ϕ-node:\n\n    v = phi .l1 x .l2 y;\n\nThen there must be assignments to `x` and `y` (recursively) preceding this statement in the CFG.\nThe paths from `x` to the `phi`-containing block and from `y` to the same block must \"converge\" at that block.\nSo insert code into the `phi`-containing block's immediate predecessors along each of those two paths:\none that does `v = id x` and one that does `v = id y`.\nThen you can delete the `phi` instruction.\n\nThis basic approach can introduce some redundant copying.\n(Take a look at the code it generates after you implement it!)\nNon-SSA copy propagation optimization can work well as a post-processing step.\nFor a more extensive take on how to translate out of SSA efficiently, see [“Revisiting Out-of-SSA Translation for Correctness, Code Quality, and Efficiency” by Boissinot et al.](https://hal.inria.fr/inria-00349925v1/document)\n\n\n\nits possible that an optimization can give overlapping phi-functions\nb0 x = 1 y = 2 B1 z = x x = y y = z if() go to b1\nin ssa form \n\nb0 x1 = 1 y1 = 2 B1 x2 = phi(x1,x3) y2 = phi(y1, y3) z = x2 x3 = y2 y3= z if() go to b1 ’’’’\noptimze it\n``` b0 x1 = 1 y1 = 2 B1 x2 = phi(x1, y2) y2 = phi(y1, x2) if() go to b1 ’’’’\nlost the temp (this is called the swap problem) if we add copies x2 = y3 y2 = x2 (uses the wrong value of x2)\nSome SSA slides from Todd Mowry at CMU",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "6 Static single assignment"
    ]
  },
  {
    "objectID": "lectures/06_ssa.html#getting-out-of-ssa",
    "href": "lectures/06_ssa.html#getting-out-of-ssa",
    "title": "6 Static single assignment",
    "section": "",
    "text": "Compilers that use the SSA form usually contain a step, before the generation of actual assembly code, in which phi functions are replaced by ordinary instructions. Normally these instructions are simple copies.\n\n\n\n\n\ngraph TD;\nsubgraph a;\n A0[\"io =\n     j0 = \n     k0 =\"]\nA1[\"i1 =\n   j1 =\n   k1 = \"]\nA2[\"i2 = phi(i0, i1\n   j2 = phi(j0, j1)\n   k2 = phi(k0, k1)\n   ...\n    = i2\n    = j2 \n    = k2\"]\n    A0 --&gt; A2\n    A1--&gt; A2\n end\nsubgraph b;\n B0[\"io =\n     j0 = \n     k0 =\"]\nB1[\"i1 =\n   j1 =\n   k1 = \"]\nB2[\"\n   ...\n    = i2\n    = j2 \n    = k2\"]\n    B0 --\"i2 = i0\n       j2 = j0\n       k2 = k0\"--&gt; B2\n    B1 --\"i2 = i1\n          j2 = j1\n          k2 = k1\"--&gt; B2\nend\n\n\n\n\n\n\n\n\n\n\n\n\ngraph TB\nA0[\"L1\n   a0 =\n   b0 =\n   if A0 &gt; b0\"]\nA1[\"b1 = a0\"]\nA2[\"l2\nb2 = phi(b1,b0)\"]\nA0 --&gt; A1\nA1--&gt; A2\nA0 --&gt; A2\n\n\n\n\n\n\nwhere do we put the copy b2 = b0?\nThe placement of the copy b2 = b0 is not simple, because the edge that links L2 to L5 is critical. A critical edge connects a block with multiple successors to a block with multiple predecessors.\nWe can solve this problem by doing critical edge splitting. This CFG transformation consists in adding an empty basic block (empty, except by – perhaps – a goto statement) between each pair of blocks connected by a critical edge.\n\n\nVery simple scheme\n\n\n\n\n\ngraph TB\nX[\"Block X\n   a = \n   b = \n   if s &gt; b\"]\nY[\"Block Y\n  b = a\"]\nZ[\"Block Z\nret b\"]\nX--&gt; Y\nY--&gt; Z\nX --&gt; Z\n\n\n\n\n\n\nThere should be a phi-function for variable b at node z of the flow graph exactly when all of the following are true:\n\nThere is a block x containing a definition of b\nThere is a block y (with y ≠ x) containing a definition of b\nThere is a nonempty path Pxz of edges from x to z\nThere is a nonempty path Pyz of edges from y to z\nPaths Pxz and Pyz do not have any node in common other than z, and…\nThe node z does not appear within both Pxz and Pyz prior to the end, though it may appear in one or the other.\n\nthis is iterative since when we add a phi, we are creating a new defintion, which may add new phi-functions\nWhen we find nodes X,Y,Z that match these steps and z does not contain a phi function for b, insert a phi\nWhile really expensive this will work\nTo convert to SSA, we want to insert ϕ-nodes whenever there are distinct paths containing distinct definitions of a variable. We don’t need ϕ-nodes in places that are dominated by a definition of the variable. So what’s a way to know when control reachable from a definition is not dominated by that definition? The dominance frontier!\nThis is going to be almost linear\nWe do it in two steps. 1) insert ϕ-nodes: 1) rename variables:\n\n\n\n\n\ngraph TB\n\na--&gt;b\na--&gt; e\na--&gt; i\n\nb--&gt;c\nc--- c\nc--&gt; d\ne--&gt; f[\"f\n  x = \"]\ne--&gt; g\ng--&gt; h\nf--&gt; h\nh--&gt;l\nf--&gt; d\nh--&gt; e\ni--&gt; k\ni--&gt; j\nj--&gt; k\nk--&gt; l\nd--&gt; l\n\n\n\n\n\n\n\nWe need phi functions for x in d and h, where else?\nwe need to iterate and keep adding phi nodes\nfor each node in the cfg \n   for each variable with a def in node\n     add node to Defs[v]   # Blocks where v is assigned.\n\nfor each v in vars:\n    W = Defs[v]\n    while W is not empty\n      remove a node n from w\n         for block in DF[d]:  # Dominance frontier.\n           Add a ϕ-node to block,\n             unless we have done so already.\n           Add block to W (because it now writes to v!),\n             unless it's already in there.\nSince we keep adding nodes to W how do we know this terminates?\nThen, rename variables:\nrename(n):\n  rename_basic_block(n)  # from before \n  for each successor Y of n, where n is the jth pred of Y\n    for each phi-function f in Y where the operand of f is 'a'\n      i = top(stack[a])\n      replace jth operand wit a_i\n  for each child of X of n (in the dominator tree)\n    rename(X)\n    for each instruction S in n\n       pop stack(S.dest)\n\n   \nThe arity of phi-functions\nCould we have a phi-function in a node with only one predecessor?\ncould we have a phi-function wit more then two arguments?\n\nThis algorithm computes what is called minimal SSA form which is not so mimimal since it can leave dead assignments\n\ni is only live in blocks l2 and l4 so no need to add phi-node at l1, this gives us pruned ssa form",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "6 Static single assignment"
    ]
  },
  {
    "objectID": "lectures/06_ssa.html#making-use-of-ssa-form",
    "href": "lectures/06_ssa.html#making-use-of-ssa-form",
    "title": "6 Static single assignment",
    "section": "",
    "text": "Our previous analyses always used a (variable, program point), but in ssa these are the same",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "6 Static single assignment"
    ]
  },
  {
    "objectID": "lectures/06_ssa.html#dead-code-elimination-in-ssa",
    "href": "lectures/06_ssa.html#dead-code-elimination-in-ssa",
    "title": "6 Static single assignment",
    "section": "",
    "text": "while there is some variable v with no uses and the statement that defines v has no other side effects, delete the statement that defines v from the program.\nwe need a counter for each variable (or each instruction)\nwalk the program once increment the counter each time the variable is used\nwhile there exists v, such that counter[v] = 0 remove the instruction that defined v, e.g., “v = E for each variable x used in E decrement counter[x]",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "6 Static single assignment"
    ]
  },
  {
    "objectID": "lectures/06_ssa.html#sparse-constant-prop",
    "href": "lectures/06_ssa.html#sparse-constant-prop",
    "title": "6 Static single assignment",
    "section": "",
    "text": "we define a partial order on consts, any &gt; all constants &gt; undefined and define the intersection of two states as the common parent\nwith each variable we have an abstract state (like a value number)\nv  = const c   ==&gt; v state is const \n\nv = id q      ==&gt; v state is the state of  q \n\nv = v0 op v1  ==&gt; if both are constants v = c0 op c1\n\n             ==&gt; if one is any, v's state is &gt; \n\nv = phi(v0,..vn) ==&gt; v's state is the intersection of the states of v0,..,vn\nWhat order do we process nodes? because the program is in ssa form we can do the nodes in dominator tree order, then before processing any instruction that is not a phi, we will have processed all the arguments\nB0: x  = input \n    a = 1 \n    c = a +10\n    if a &lt; c go to b1\n\nB1: b = x * a\n    print b \n    a = a +1 \n    go to b1\n\nin ssa form \n\nB0: x0  = input \n    a0 = 1 \n    c0 = a0 +10\n    if a0 &lt; c0 go to b1\n\nB1: a1 phi(a1,a2 )\n    b0 = x0 * a1\n    print b0 \n    a2 = a1 +1 \n    go to b1\n\nwalking the dominator tree b0 -&gt; b1\nB0:\nx0 - any \na0 - 1 \nc0 - 11 (folding the constant)\na0 &lt; c0  skip\nB1:\na1 = 1 (only one input of phi is defined)\nb0 = any\na2 = 2\n\nupdate the uses of a2 - which is the phi a1 -&gt; any\nupdate the uses of a1 which is the increment no change \n\n\n\n## liveness \n\n![](images/StaticSingleAssignment_Part69.jpg)\n\n![](images/StaticSingleAssignment_Part70.jpg)\n\n![](images/StaticSingleAssignment_Part71.jpg)\n\n\n![](images/StaticSingleAssignment_Part73.jpg)\n\n\n\n\n### Converting from SSA\n\nEventually, we need to convert *out of* SSA form to generate efficient code for real machines that don't have `phi`-nodes and do have finite space for variable storage.\n\nThe basic algorithm is pretty straightforward.\nIf you have a ϕ-node:\n\n    v = phi .l1 x .l2 y;\n\nThen there must be assignments to `x` and `y` (recursively) preceding this statement in the CFG.\nThe paths from `x` to the `phi`-containing block and from `y` to the same block must \"converge\" at that block.\nSo insert code into the `phi`-containing block's immediate predecessors along each of those two paths:\none that does `v = id x` and one that does `v = id y`.\nThen you can delete the `phi` instruction.\n\nThis basic approach can introduce some redundant copying.\n(Take a look at the code it generates after you implement it!)\nNon-SSA copy propagation optimization can work well as a post-processing step.\nFor a more extensive take on how to translate out of SSA efficiently, see [“Revisiting Out-of-SSA Translation for Correctness, Code Quality, and Efficiency” by Boissinot et al.](https://hal.inria.fr/inria-00349925v1/document)\n\n\n\nits possible that an optimization can give overlapping phi-functions\nb0 x = 1 y = 2 B1 z = x x = y y = z if() go to b1\nin ssa form \n\nb0 x1 = 1 y1 = 2 B1 x2 = phi(x1,x3) y2 = phi(y1, y3) z = x2 x3 = y2 y3= z if() go to b1 ’’’’\noptimze it\n``` b0 x1 = 1 y1 = 2 B1 x2 = phi(x1, y2) y2 = phi(y1, x2) if() go to b1 ’’’’\nlost the temp (this is called the swap problem) if we add copies x2 = y3 y2 = x2 (uses the wrong value of x2)\nSome SSA slides from Todd Mowry at CMU",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "6 Static single assignment"
    ]
  },
  {
    "objectID": "lectures/12_memory.html",
    "href": "lectures/12_memory.html",
    "title": "12_memory.qmd",
    "section": "",
    "text": "Warning\n\n\n\nnot done\n\n\n\n\n\n Back to top",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "12_memory.qmd"
    ]
  },
  {
    "objectID": "lectures/02b_representation.html",
    "href": "lectures/02b_representation.html",
    "title": "2b Representation",
    "section": "",
    "text": "The representation of a program - is what we read in and read out when transforming a program. What kind of properties make a good representation?\nOne possible representation is called concrete syntax form Programs are text - surface syntax- just what you would type into an editor.\n\nvalue = 8\nresult = 1\nfor i in range(value):\n  result = result + i\nprint(result)\n\n29\n\n\nWhat is good and what is bad about this representation?\nWhat is the level of abstraction? How do you understand the semantics.\nForm 2 - Abstract syntax form\nTree structure - Nodes are parts of the program, edges show how they are connected. We can write this as a list or a graph\n\n\nFunctionDef(\n    name='pgm',\n    args=arguments(\n        posonlyargs=[],\n        args=[],\n        kwonlyargs=[],\n        kw_defaults=[],\n        defaults=[]),\n    body=[\n        Assign(\n            targets=[\n                Name(id='value', ctx=Store())],\n            value=Constant(value=8)),\n        Assign(\n            targets=[\n                Name(id='result', ctx=Store())],\n            value=Constant(value=1)),\n        For(\n            target=Name(id='i', ctx=Store()),\n            iter=Call(\n                func=Name(id='range', ctx=Load()),\n                args=[\n                    Name(id='value', ctx=Load())],\n                keywords=[]),\n            body=[\n                Assign(\n                    targets=[\n                        Name(id='result', ctx=Store())],\n                    value=BinOp(\n                        left=Name(id='result', ctx=Load()),\n                        op=Mult(),\n                        right=Name(id='i', ctx=Load())))],\n            orelse=[]),\n        Expr(\n            value=Call(\n                func=Name(id='print', ctx=Load()),\n                args=[\n                    Name(id='result', ctx=Load())],\n                keywords=[]))],\n    decorator_list=[])\n\n\n\ndot_dia\n\n\n\n\n\n\n\n\nAST tree representation An AST is a tree structure, nodes like if, test, body, assign Each node is one concept from the program\nRecursive function can walk over the tree, one chunk of code for each node.\n\nGood - each type of node is different, making special cases are easy\nBad - each type of node is different so analysis has to know about every type, making general cases hard\n\nThis is the classic way to write an interpreter. Simple (non optimizing) compilers often use this format.\n\n\nPrograms are lists of instructions. Like an assembly instructions. Same sort of representation as LLVM.\n\n\n    let value = 8\n    let result = 1\n    for (let i = 0;i &lt; value;i = i+ 1)\n    {\n        result = result * i\n    }\n    console.log(result )\n\n\n\n@main {\n  v0: float = const 8;\n  value: float = id v0;\n  v1: float = const 1;\n  result: float = id v1;\n  v3: float = const 0;\n  i: float = id v3;\n.for.cond.2:\n  v4: float = id i;\n  v5: float = id value;\n  v6: bool = flt v4 v5;\n  br v6 .for.body.2 .for.end.2;\n.for.body.2:\n  v7: float = id result;\n  v8: float = id i;\n  v9: float = fmul v7 v8;\n  result: float = id v9;\n  v10: float = id i;\n  v11: float = const 1;\n  v12: float = fadd v10 v11;\n  i: float = id v12;\n  jmp .for.cond.2;\n.for.end.2:\n  v13: float = id result;\n  print v13;\n  v14: int = const 0;\n}\n\n\n\n\nos.system('ts2bril images/toy.ts | bril2txt')\n\n@main {\n  v0: float = const 8;\n  value: float = id v0;\n  v1: float = const 1;\n  result: float = id v1;\n  v3: float = const 0;\n  i: float = id v3;\n.for.cond.2:\n  v4: float = id i;\n  v5: float = id value;\n  v6: bool = flt v4 v5;\n  br v6 .for.body.2 .for.end.2;\n.for.body.2:\n  v7: float = id result;\n  v8: float = id i;\n  v9: float = fmul v7 v8;\n  result: float = id v9;\n  v10: float = id i;\n  v11: float = const 1;\n  v12: float = fadd v10 v11;\n  i: float = id v12;\n  jmp .for.cond.2;\n.for.end.2:\n  v13: float = id result;\n  print v13;\n  v14: int = const 0;\n}\n\n\n0\n\n\nLooks like assembly but no limit on registers, no condition codes. fully typed, no complex addressing modes.\nsyntax-\nDeclare functions, labels, instructions\ninstruction:\n1) variable type = opcode arguments 2) opcode list of arguments\n\n\n\nWhat is the abstract syntax form for this?\n\n\n\n\n\nRepresentation is a directed graph. Nodes are instructions, edges indicate possible flow of control, one entry and one exit node.\nHere is a simple program:\n    @main {\n        v: int = const 5;\n        print v;\n    }\n\n\n\n\n\nflowchart LR\n  A[const] --&gt; B[print]\n\n\n\n\n\n\na second example\n    @main {\n        v: int = const 4;\n        jmp  .somewhere;\n        v: int = const 2;\n        .somewhere;\n        print v;\n    }\nWhat does the control flow graph look like?\n\n\n\n\n\nflowchart LR\n  A[const 4] --&gt; B[jmp]\n  B --&gt; C[print]\n  D[const 2] --&gt; C\n\n\n\n\n\n\nnotice label does not produce a node\nEasy to see a dead instruction.\nThird example:\n    @main {\n        v: int = const 4;\n        b: bool = const false;\n        br b .there .here;\n    .here:\n        v: int = const 2;\n    .there;\n        print v;\n    }\n\n\n\n\n\nflowchart LR\n  A[v: int const 4] --&gt; B[b: bool const false]\n  B --&gt; C[br b .there, .false]\n  C --&gt; D[v: const 2]\n  C --&gt; E[print v]\n  D --&gt; E\n\n\n\n\n\n\nwhich is the true and which is the false, could mark the edges or use a convention\nWhich is the entry, which is the exit?\nThere is a long chain of instructions entered at the top, exit at the bottom, no branches inside.\nBasic blocks (cfg form 2) 1) nodes can be a sequence of instructions. 1) jumps and branches can only be at the end of a sequence 1) only label has to be at the start 1) every instruction in the sequence executes the same number of times\n\n\n\n\n\nflowchart LR\n  A[v: int const 4\\nb : bool\\n br ] \n  A --&gt; D[v: const 2]\n  A --&gt; E[print v]\n  D --&gt; E\n\n\n\n\n\n\nAs we construct basic blocks, we can add instructions up till something that ends the block (terminator)\nOption: do all blocks end in a terminator or not?\ngiven a block b, the predecessors of b are the blocks b_in where there is an edge bin-&gt;b. And the successors of B are the b_out where b-&gt;b_out is an edge\n\n\n\n\n\njust find all the basic blocks\nadd the control flow edges\n\npsuedo code\n\nin: instructions - list of instructions\nout blocks - list of lists of instructions\n\ncurrent_block = []\nfor i in instructions:\n    if i is not a label:\n       block.append(i)\n    if i is a label or terminator:\n        blocks.append(current_block)\n        current_block = []\nstep 2 we need a map from labels to basic blocks\n\nin: instructions - list of instructions\nout blocks - list of lists of instructions\n\ncurrent_block = []\nfor i in instructions:\n    if i is not a label:\n       block.append(i)\n    if i is a label or terminator:\n        blocks.append(current_block)\n        current_block = []\n    \n\nfor block in blocks:\n   last = block[-1]\n   if last is a jmp (one successor)\n      add edge from block to last.dest \n   else if last is a br (two successors)\n      add two edges from block to last.true, last.false \n   else  fall through \n      add edge to next block (if it exists)\n\nwith open(\"images/add.json\", 'r') as f:\n  bril_program = f.read()\n  print(bril_program)\n\n{\n  \"functions\": [\n    {\n      \"name\": \"main\",\n      \"instrs\": [\n        { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v0\", \"value\": 1 },\n        { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v1\", \"value\": 2 },\n        { \"op\": \"add\", \"type\": \"int\", \"dest\": \"v2\",\n          \"args\": [\"v0\", \"v1\"] },\n        { \"op\": \"print\", \"args\": [\"v2\"] }\n      ],\n      \"args\": []\n    }\n  ]\n}",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "2b Representation"
    ]
  },
  {
    "objectID": "lectures/02b_representation.html#a-more-regular-representation",
    "href": "lectures/02b_representation.html#a-more-regular-representation",
    "title": "2b Representation",
    "section": "",
    "text": "Programs are lists of instructions. Like an assembly instructions. Same sort of representation as LLVM.\n\n\n    let value = 8\n    let result = 1\n    for (let i = 0;i &lt; value;i = i+ 1)\n    {\n        result = result * i\n    }\n    console.log(result )\n\n\n\n@main {\n  v0: float = const 8;\n  value: float = id v0;\n  v1: float = const 1;\n  result: float = id v1;\n  v3: float = const 0;\n  i: float = id v3;\n.for.cond.2:\n  v4: float = id i;\n  v5: float = id value;\n  v6: bool = flt v4 v5;\n  br v6 .for.body.2 .for.end.2;\n.for.body.2:\n  v7: float = id result;\n  v8: float = id i;\n  v9: float = fmul v7 v8;\n  result: float = id v9;\n  v10: float = id i;\n  v11: float = const 1;\n  v12: float = fadd v10 v11;\n  i: float = id v12;\n  jmp .for.cond.2;\n.for.end.2:\n  v13: float = id result;\n  print v13;\n  v14: int = const 0;\n}\n\n\n\n\nos.system('ts2bril images/toy.ts | bril2txt')\n\n@main {\n  v0: float = const 8;\n  value: float = id v0;\n  v1: float = const 1;\n  result: float = id v1;\n  v3: float = const 0;\n  i: float = id v3;\n.for.cond.2:\n  v4: float = id i;\n  v5: float = id value;\n  v6: bool = flt v4 v5;\n  br v6 .for.body.2 .for.end.2;\n.for.body.2:\n  v7: float = id result;\n  v8: float = id i;\n  v9: float = fmul v7 v8;\n  result: float = id v9;\n  v10: float = id i;\n  v11: float = const 1;\n  v12: float = fadd v10 v11;\n  i: float = id v12;\n  jmp .for.cond.2;\n.for.end.2:\n  v13: float = id result;\n  print v13;\n  v14: int = const 0;\n}\n\n\n0\n\n\nLooks like assembly but no limit on registers, no condition codes. fully typed, no complex addressing modes.\nsyntax-\nDeclare functions, labels, instructions\ninstruction:\n1) variable type = opcode arguments 2) opcode list of arguments",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "2b Representation"
    ]
  },
  {
    "objectID": "lectures/02b_representation.html#what-is-good-and-what-is-about-this-reorientation",
    "href": "lectures/02b_representation.html#what-is-good-and-what-is-about-this-reorientation",
    "title": "2b Representation",
    "section": "",
    "text": "What is the abstract syntax form for this?",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "2b Representation"
    ]
  },
  {
    "objectID": "lectures/02b_representation.html#extract-info-from-this-repreentation.",
    "href": "lectures/02b_representation.html#extract-info-from-this-repreentation.",
    "title": "2b Representation",
    "section": "",
    "text": "Representation is a directed graph. Nodes are instructions, edges indicate possible flow of control, one entry and one exit node.\nHere is a simple program:\n    @main {\n        v: int = const 5;\n        print v;\n    }\n\n\n\n\n\nflowchart LR\n  A[const] --&gt; B[print]\n\n\n\n\n\n\na second example\n    @main {\n        v: int = const 4;\n        jmp  .somewhere;\n        v: int = const 2;\n        .somewhere;\n        print v;\n    }\nWhat does the control flow graph look like?\n\n\n\n\n\nflowchart LR\n  A[const 4] --&gt; B[jmp]\n  B --&gt; C[print]\n  D[const 2] --&gt; C\n\n\n\n\n\n\nnotice label does not produce a node\nEasy to see a dead instruction.\nThird example:\n    @main {\n        v: int = const 4;\n        b: bool = const false;\n        br b .there .here;\n    .here:\n        v: int = const 2;\n    .there;\n        print v;\n    }\n\n\n\n\n\nflowchart LR\n  A[v: int const 4] --&gt; B[b: bool const false]\n  B --&gt; C[br b .there, .false]\n  C --&gt; D[v: const 2]\n  C --&gt; E[print v]\n  D --&gt; E\n\n\n\n\n\n\nwhich is the true and which is the false, could mark the edges or use a convention\nWhich is the entry, which is the exit?\nThere is a long chain of instructions entered at the top, exit at the bottom, no branches inside.\nBasic blocks (cfg form 2) 1) nodes can be a sequence of instructions. 1) jumps and branches can only be at the end of a sequence 1) only label has to be at the start 1) every instruction in the sequence executes the same number of times\n\n\n\n\n\nflowchart LR\n  A[v: int const 4\\nb : bool\\n br ] \n  A --&gt; D[v: const 2]\n  A --&gt; E[print v]\n  D --&gt; E\n\n\n\n\n\n\nAs we construct basic blocks, we can add instructions up till something that ends the block (terminator)\nOption: do all blocks end in a terminator or not?\ngiven a block b, the predecessors of b are the blocks b_in where there is an edge bin-&gt;b. And the successors of B are the b_out where b-&gt;b_out is an edge",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "2b Representation"
    ]
  },
  {
    "objectID": "lectures/02b_representation.html#what-is-an-algorithm-that-forms-a-cfg",
    "href": "lectures/02b_representation.html#what-is-an-algorithm-that-forms-a-cfg",
    "title": "2b Representation",
    "section": "",
    "text": "just find all the basic blocks\nadd the control flow edges\n\npsuedo code\n\nin: instructions - list of instructions\nout blocks - list of lists of instructions\n\ncurrent_block = []\nfor i in instructions:\n    if i is not a label:\n       block.append(i)\n    if i is a label or terminator:\n        blocks.append(current_block)\n        current_block = []\nstep 2 we need a map from labels to basic blocks\n\nin: instructions - list of instructions\nout blocks - list of lists of instructions\n\ncurrent_block = []\nfor i in instructions:\n    if i is not a label:\n       block.append(i)\n    if i is a label or terminator:\n        blocks.append(current_block)\n        current_block = []\n    \n\nfor block in blocks:\n   last = block[-1]\n   if last is a jmp (one successor)\n      add edge from block to last.dest \n   else if last is a br (two successors)\n      add two edges from block to last.true, last.false \n   else  fall through \n      add edge to next block (if it exists)\n\nwith open(\"images/add.json\", 'r') as f:\n  bril_program = f.read()\n  print(bril_program)\n\n{\n  \"functions\": [\n    {\n      \"name\": \"main\",\n      \"instrs\": [\n        { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v0\", \"value\": 1 },\n        { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v1\", \"value\": 2 },\n        { \"op\": \"add\", \"type\": \"int\", \"dest\": \"v2\",\n          \"args\": [\"v0\", \"v1\"] },\n        { \"op\": \"print\", \"args\": [\"v2\"] }\n      ],\n      \"args\": []\n    }\n  ]\n}",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "2b Representation"
    ]
  },
  {
    "objectID": "src/briltxt/docs/lang/memory.html",
    "href": "src/briltxt/docs/lang/memory.html",
    "title": "Manually Managed Memory",
    "section": "",
    "text": "While core Bril only has simple scalar stack values, the memory extension adds a manually managed heap of array-like allocations. You can create regions, like with malloc in C, and it is the program’s responsibility to delete them, like with free. Programs can manipulate pointers within these regions; a pointer indicates a particular offset within a particular allocated region.\nYou can read more about the memory extension from its creators, Drew Zagieboylo and Ryan Doenges.\n\n\nThe memory extension adds a parameterized ptr type to Bril:\n{\"ptr\": &lt;Type&gt;}\nA pointer value represents a reference to a specific offset within a uniformly-typed region of values.\n\n\n\nThese are the operations that manipulate memory allocations:\n\nalloc: Create a new memory region. One argument: the number of values to allocate (an integer). The result type is a pointer; the type of the instruction decides the type of the memory region to allocate. For example, this instruction allocates a region of integers:\n{\n    \"op\": \"alloc\",\n    \"args\": [\"size\"],\n    \"dest\": \"myptr\",\n    \"type\": {\"ptr\": \"int\"}\n}\nfree: Delete an allocation. One argument: a pointer produced by alloc. No return value.\nstore: Write into a memory region. Two arguments: a pointer and a value. The pointer type must agree with the value type (e.g., if the second argument is an int, the first argument must be a ptr&lt;int&gt;). No return value.\nload: Read from memory. One argument: a pointer. The return type is the pointed-to type for that pointer.\nptradd: Adjust the offset for a pointer, producing a new pointer to a different location in the same memory region. Two arguments: a pointer and an offset (an integer, which may be negative). The return type is the same as the original pointer type.\n\nIt is an error to access or free a region that has already been freed. It is also an error to access (load or store) a pointer that is out of bounds, i.e., outside the range of valid indices for a given allocation. (Doing a ptradd to produce an out-of-bounds pointer is not an error; subsequently accessing that pointer is.)\n\n\n\nIt is not an error to use the core print operation on pointers, but the output is not specified. Implementations can choose to print any representation of the pointer that they deem helpful."
  },
  {
    "objectID": "src/briltxt/docs/lang/memory.html#types",
    "href": "src/briltxt/docs/lang/memory.html#types",
    "title": "Manually Managed Memory",
    "section": "",
    "text": "The memory extension adds a parameterized ptr type to Bril:\n{\"ptr\": &lt;Type&gt;}\nA pointer value represents a reference to a specific offset within a uniformly-typed region of values."
  },
  {
    "objectID": "src/briltxt/docs/lang/memory.html#operations",
    "href": "src/briltxt/docs/lang/memory.html#operations",
    "title": "Manually Managed Memory",
    "section": "",
    "text": "These are the operations that manipulate memory allocations:\n\nalloc: Create a new memory region. One argument: the number of values to allocate (an integer). The result type is a pointer; the type of the instruction decides the type of the memory region to allocate. For example, this instruction allocates a region of integers:\n{\n    \"op\": \"alloc\",\n    \"args\": [\"size\"],\n    \"dest\": \"myptr\",\n    \"type\": {\"ptr\": \"int\"}\n}\nfree: Delete an allocation. One argument: a pointer produced by alloc. No return value.\nstore: Write into a memory region. Two arguments: a pointer and a value. The pointer type must agree with the value type (e.g., if the second argument is an int, the first argument must be a ptr&lt;int&gt;). No return value.\nload: Read from memory. One argument: a pointer. The return type is the pointed-to type for that pointer.\nptradd: Adjust the offset for a pointer, producing a new pointer to a different location in the same memory region. Two arguments: a pointer and an offset (an integer, which may be negative). The return type is the same as the original pointer type.\n\nIt is an error to access or free a region that has already been freed. It is also an error to access (load or store) a pointer that is out of bounds, i.e., outside the range of valid indices for a given allocation. (Doing a ptradd to produce an out-of-bounds pointer is not an error; subsequently accessing that pointer is.)"
  },
  {
    "objectID": "src/briltxt/docs/lang/memory.html#printing",
    "href": "src/briltxt/docs/lang/memory.html#printing",
    "title": "Manually Managed Memory",
    "section": "",
    "text": "It is not an error to use the core print operation on pointers, but the output is not specified. Implementations can choose to print any representation of the pointer that they deem helpful."
  },
  {
    "objectID": "src/briltxt/docs/lang/ssa.html",
    "href": "src/briltxt/docs/lang/ssa.html",
    "title": "Static Single Assignment (SSA) Form",
    "section": "",
    "text": "This language extension lets you represent Bril programs in static single assignment (SSA) form. As in the standard definition, an SSA-form Bril program contains only one assignment per variable, globally—that is, variables within a function cannot be reassigned. This extension adds ϕ-nodes to the language.\n\n\nThere is one new instruction:\n\nphi: Takes n labels and n arguments, for any n. Copies the value of the ith argument, where i is the index of the second-most-recently-executed label. (It is an error to use a phi instruction when two labels have not yet executed, or when the instruction does not contain an entry for the second-most-recently-executed label.)\n\nIntuitively, a phi instruction takes its value according to the current basic block’s predecessor.\n\n\n\nIn the text format, you can write phi instructions like this:\nx: int = phi a .here b .there;\nThe text format doesn’t care how you interleave arguments and labels, so this is equivalent to (but more readable than) phi a b .here .there. The “second-most-recent label” rule means that the labels refer to predecessor basic blocks, if you imagine blocks being “named” by their labels.\nHere’s a small example:\n.top:\n  a: int = const 5;\n  br cond .here .there;\n.here:\n  b: int = const 7;\n.there:\n  c: int = phi a .top b .here;\n  print c;\nA phi instruction is sensitive to the incoming CFG edge that execution took to arrive at the current block. The phi instruction in this program, for example, gets its value from a if control came from the .top block and b if control came from the .here block.\nThe reference interpreter can supports programs in SSA form because it can faithfully execute the phi instruction."
  },
  {
    "objectID": "src/briltxt/docs/lang/ssa.html#operations",
    "href": "src/briltxt/docs/lang/ssa.html#operations",
    "title": "Static Single Assignment (SSA) Form",
    "section": "",
    "text": "There is one new instruction:\n\nphi: Takes n labels and n arguments, for any n. Copies the value of the ith argument, where i is the index of the second-most-recently-executed label. (It is an error to use a phi instruction when two labels have not yet executed, or when the instruction does not contain an entry for the second-most-recently-executed label.)\n\nIntuitively, a phi instruction takes its value according to the current basic block’s predecessor."
  },
  {
    "objectID": "src/briltxt/docs/lang/ssa.html#examples",
    "href": "src/briltxt/docs/lang/ssa.html#examples",
    "title": "Static Single Assignment (SSA) Form",
    "section": "",
    "text": "In the text format, you can write phi instructions like this:\nx: int = phi a .here b .there;\nThe text format doesn’t care how you interleave arguments and labels, so this is equivalent to (but more readable than) phi a b .here .there. The “second-most-recent label” rule means that the labels refer to predecessor basic blocks, if you imagine blocks being “named” by their labels.\nHere’s a small example:\n.top:\n  a: int = const 5;\n  br cond .here .there;\n.here:\n  b: int = const 7;\n.there:\n  c: int = phi a .top b .here;\n  print c;\nA phi instruction is sensitive to the incoming CFG edge that execution took to arrive at the current block. The phi instruction in this program, for example, gets its value from a if control came from the .top block and b if control came from the .here block.\nThe reference interpreter can supports programs in SSA form because it can faithfully execute the phi instruction."
  },
  {
    "objectID": "src/briltxt/docs/lang/spec.html",
    "href": "src/briltxt/docs/lang/spec.html",
    "title": "Speculative Execution",
    "section": "",
    "text": "This extension lets Bril programs use a form of explicit speculative execution with rollback.\nIn general, speculation is when programs perform work that might not actually be necessary or even correct, under the assumption that it is likely to be right and useful. If this assumption turns out to be wrong, speculation typically needs some rollback mechanism to undo incorrect side effects and recover to a correct state.\nIn this Bril extension, programs can explicitly enter a speculative mode, where variable assignments are temporary. Then, they can either abort or commit those assignments, discarding them or making them permanent.\n\n\n\nspeculate: Enter a speculative execution context. No arguments.\ncommit: End the current speculative context, committing the current speculative state as the “real” state. No arguments.\nguard: Check a condition and possibly abort the current speculative context. One argument, the Boolean condition, and one label, to which control is transferred on abort. If the condition is true, this is a no-op. If the condition is false, speculation aborts: the program state rolls back to the state at the corresponding speculate instruction, execution jumps to the specified label.\n\nSpeculation can be nested, in which case aborting or committing a child context returns execution to the parent context. Aborting speculation rolls back normal variable assignments, but it does not affect the memory extension’s heap—any changes there remain. It is an error to commit or abort outside of speculation. It is not an error to perform side effects like print during speculation, but it is probably a bad idea.\n\n\n\nCommitting a speculative update makes it behave like normal:\nv: int = const 4;\nspeculate;\nv: int = const 2;\ncommit;\nprint v;\nSo this example prints 2. However, when a guard fails, it rolls back any modifications that happened since the last speculate instruction:\n  b: bool = const false;\n\n  v: int = const 4;\n  speculate;\n  v: int = const 2;\n  guard b .failed;\n  commit;\n\n.failed:\n  print v;\nThe guard here fails because b is false, then v gets restored to its pre-speculation value, and then control transfers to the .failed label. So this example prints 4. You can think of the code at .failed as the “recovery routine” that handles exceptional conditions.\n\n\n\nThe reference interpreter supports speculative execution. However, it does not support function calls during speculation, so you will get an error if you try to use a call or ret instruction while speculating."
  },
  {
    "objectID": "src/briltxt/docs/lang/spec.html#operations",
    "href": "src/briltxt/docs/lang/spec.html#operations",
    "title": "Speculative Execution",
    "section": "",
    "text": "speculate: Enter a speculative execution context. No arguments.\ncommit: End the current speculative context, committing the current speculative state as the “real” state. No arguments.\nguard: Check a condition and possibly abort the current speculative context. One argument, the Boolean condition, and one label, to which control is transferred on abort. If the condition is true, this is a no-op. If the condition is false, speculation aborts: the program state rolls back to the state at the corresponding speculate instruction, execution jumps to the specified label.\n\nSpeculation can be nested, in which case aborting or committing a child context returns execution to the parent context. Aborting speculation rolls back normal variable assignments, but it does not affect the memory extension’s heap—any changes there remain. It is an error to commit or abort outside of speculation. It is not an error to perform side effects like print during speculation, but it is probably a bad idea."
  },
  {
    "objectID": "src/briltxt/docs/lang/spec.html#examples",
    "href": "src/briltxt/docs/lang/spec.html#examples",
    "title": "Speculative Execution",
    "section": "",
    "text": "Committing a speculative update makes it behave like normal:\nv: int = const 4;\nspeculate;\nv: int = const 2;\ncommit;\nprint v;\nSo this example prints 2. However, when a guard fails, it rolls back any modifications that happened since the last speculate instruction:\n  b: bool = const false;\n\n  v: int = const 4;\n  speculate;\n  v: int = const 2;\n  guard b .failed;\n  commit;\n\n.failed:\n  print v;\nThe guard here fails because b is false, then v gets restored to its pre-speculation value, and then control transfers to the .failed label. So this example prints 4. You can think of the code at .failed as the “recovery routine” that handles exceptional conditions."
  },
  {
    "objectID": "src/briltxt/docs/lang/spec.html#interpreter",
    "href": "src/briltxt/docs/lang/spec.html#interpreter",
    "title": "Speculative Execution",
    "section": "",
    "text": "The reference interpreter supports speculative execution. However, it does not support function calls during speculation, so you will get an error if you try to use a call or ret instruction while speculating."
  },
  {
    "objectID": "src/briltxt/docs/lang/wellformed.html",
    "href": "src/briltxt/docs/lang/wellformed.html",
    "title": "Well Formedness",
    "section": "",
    "text": "Well Formedness\nNot every syntactically complete Bril program is well formed. Here is an incomplete list of rules that well-formed Bril programs must follow:\n\nInstructions may name variables as arguments when they are defined elsewhere in the function. Similarly, they may only refer to labels that exist within the same function, and they can only refer to functions defined somewhere in the same file.\nDynamically speaking, during execution, instructions may refer only to variables that have already been defined earlier in execution. (This is a dynamic property, not a static property.)\nEvery variable may have only a single type within a function. It is illegal to have two assignments to the same variable with different types, even if the function’s logic guarantees that it is impossible to execute both instructions in a single call.\nMany operations have constraints on the types of arguments they can take; well-formed programs always provide the right type of value.\n\nTools do not need to handle ill-formed Bril programs. As someone working with Bril, you never need to check for well-formedness and can do anything when fed with ill-formed code, including silently working just fine, producing ill-formed output, or crashing and burning.\nTo help check for well-formedness, the reference interpreter has many dynamic checks and the type inference tool can check types statically.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "src/briltxt/docs/lang/import.html",
    "href": "src/briltxt/docs/lang/import.html",
    "title": "Import",
    "section": "",
    "text": "Typically, Bril programs are self-contained: they only use functions defined elsewhere in the same program. This import extension lets Bril code use functions defined in other files.\nA Bril import refers to a file and lists the functions to import from it, like this:\n{\n    \"path\": \"my_library.json\",\n    \"functions\": [{\"name\": \"libfunc\"}]\n}\nThis import assumes that there’s a Bril file called my_library.json, and that it declares a function @libfunc. The current Bril file may now invoke @libfunc as if it were defined locally.\n\n\nThe top-level Bril program is extended with an imports field:\n{ \"functions\": [&lt;Function&gt;, ...], \"imports\": [&lt;Import&gt;, ...] }\nEach import object has this syntax:\n{\n    \"path\": \"&lt;string&gt;\",\n    \"functions\": [\n        { \"name\": \"&lt;string&gt;\", \"alias\": \"&lt;string&gt;\"? },\n        ...\n    ]\n}\nThe path is a relative reference to a Bril JSON file containing the functions to import. In the objects in the functions list, the name is the original name of the function, and the optional alias is the local name that the program will use to refer to the function. A missing alias makes the local name equal to the original name.\nIt is an error to refer to functions that do not exist, or to create naming conflicts between imports and local functions (or between different imports). Import cycles are allowed.\n\n\n\nIn Bril’s text format, the import syntax looks like this:\nfrom \"something.json\" import @libfunc, @otherfunc as @myfunc;\n\n\n\nWe do not define the exact mechanism for using the path string to find the file to import. Reasonable options include:\n\nResolve the path relative to the file the import appears in.\nUse a pre-defined set of library search paths.\n\nWe only specify what it means to import JSON files; implementations can choose to allow importing other kinds of files too (e.g., text-format source code)."
  },
  {
    "objectID": "src/briltxt/docs/lang/import.html#syntax",
    "href": "src/briltxt/docs/lang/import.html#syntax",
    "title": "Import",
    "section": "",
    "text": "The top-level Bril program is extended with an imports field:\n{ \"functions\": [&lt;Function&gt;, ...], \"imports\": [&lt;Import&gt;, ...] }\nEach import object has this syntax:\n{\n    \"path\": \"&lt;string&gt;\",\n    \"functions\": [\n        { \"name\": \"&lt;string&gt;\", \"alias\": \"&lt;string&gt;\"? },\n        ...\n    ]\n}\nThe path is a relative reference to a Bril JSON file containing the functions to import. In the objects in the functions list, the name is the original name of the function, and the optional alias is the local name that the program will use to refer to the function. A missing alias makes the local name equal to the original name.\nIt is an error to refer to functions that do not exist, or to create naming conflicts between imports and local functions (or between different imports). Import cycles are allowed."
  },
  {
    "objectID": "src/briltxt/docs/lang/import.html#text-format",
    "href": "src/briltxt/docs/lang/import.html#text-format",
    "title": "Import",
    "section": "",
    "text": "In Bril’s text format, the import syntax looks like this:\nfrom \"something.json\" import @libfunc, @otherfunc as @myfunc;"
  },
  {
    "objectID": "src/briltxt/docs/lang/import.html#search-paths",
    "href": "src/briltxt/docs/lang/import.html#search-paths",
    "title": "Import",
    "section": "",
    "text": "We do not define the exact mechanism for using the path string to find the file to import. Reasonable options include:\n\nResolve the path relative to the file the import appears in.\nUse a pre-defined set of library search paths.\n\nWe only specify what it means to import JSON files; implementations can choose to allow importing other kinds of files too (e.g., text-format source code)."
  },
  {
    "objectID": "src/briltxt/docs/SUMMARY.html",
    "href": "src/briltxt/docs/SUMMARY.html",
    "title": "Summary",
    "section": "",
    "text": "Summary\nIntroduction\n\nLanguage Reference\n\nSyntax\nWell Formedness\nCore\nStatic Single Assignment\nMemory\nFloating Point\nSpeculative Execution\nImport\nCharacter\n\nTools\n\nInterpreter\nText Representation\nTypeScript Compiler\nFast Interpreter\nEditor Plugin\nType Inference\nType Checker\nBenchmarks\nTypeScript Library\nOCaml Library\nRust Library\nBenchmark Runner\nCompiler\nWeb Playground\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "src/briltxt/docs/tools/text.html",
    "href": "src/briltxt/docs/tools/text.html",
    "title": "Bril Text Format",
    "section": "",
    "text": "While Bril’s canonical representation is a JSON AST, humans don’t like to read and write JSON. To accommodate our human foibles, we also have a simple textual representation. There is a parser and pretty printer tool that can convert the text representation to and from JSON.\nFor example, this Bril program in JSON:\n{\n  \"functions\": [{\n    \"name\": \"main\",\n    \"instrs\": [\n      { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v0\", \"value\": 1 },\n      { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v1\", \"value\": 2 },\n      { \"op\": \"add\", \"type\": \"int\", \"dest\": \"v2\", \"args\": [\"v0\", \"v1\"] },\n      { \"op\": \"print\", \"args\": [\"v2\"] },\n      { \"op\": \"alloc\", \"type\": { \"ptr\" : \"int\" }, \"dest\": \"v3\", \"args\": [\"v0\"] },\n      { \"op\": \"free\", \"args\": [\"v3\"] },\n    ]\n  }]\n}\nGets represented in text like this:\n@main {\n  v0: int = const 1;\n  v1: int = const 2;\n  v2: int = add v0 v1;\n  print v2;\n  v3: ptr&lt;int&gt; = alloc v0;\n  free v3;\n}\n\n\nThe bril-txt parser & pretty printer are written in Python. You can install them with Flit by doing something like:\n$ pip install --user flit\n$ cd bril-txt\n$ flit install --symlink --user\nYou’ll now have tools called bril2json and bril2txt. Both read from standard input and write to standard output. You can try a “round trip” like this, for example:\n$ bril2json &lt; test/parse/add.bril | bril2txt\nThe bril2json parser also supports a -p flag to include source positions."
  },
  {
    "objectID": "src/briltxt/docs/tools/text.html#tools",
    "href": "src/briltxt/docs/tools/text.html#tools",
    "title": "Bril Text Format",
    "section": "",
    "text": "The bril-txt parser & pretty printer are written in Python. You can install them with Flit by doing something like:\n$ pip install --user flit\n$ cd bril-txt\n$ flit install --symlink --user\nYou’ll now have tools called bril2json and bril2txt. Both read from standard input and write to standard output. You can try a “round trip” like this, for example:\n$ bril2json &lt; test/parse/add.bril | bril2txt\nThe bril2json parser also supports a -p flag to include source positions."
  },
  {
    "objectID": "src/briltxt/docs/tools/brilift.html",
    "href": "src/briltxt/docs/tools/brilift.html",
    "title": "Cranelift Compiler",
    "section": "",
    "text": "Brilift is a ahead-of-time or just-in-time compiler from Bril to native code using the Cranelift code generator. It supports core Bril, floating point, and the memory extension.\nIn AOT mode, Brilift emits .o files and also provides a simple run-time library. By linking these together, you get a complete native executable. In JIT mode, Brilift mimics an interpreter.\n\n\nBrilift is a Rust project using the bril-rs library. You can build it using Cargo:\n$ cd brilift\n$ cargo run -- --help\n$ cargo install --path .  # If you want the executable on your $PATH.\n\n\n\nProvide the brilift executable with a Bril JSON program:\n$ bril2json &lt; something.bril | brilift\nBy default, Brilift produces a file bril.o. (You can pick your own output filename with -o something.o; see the full list of options below.)\nA complete executable will also need our runtime library, which is in rt.c. There is a convenient Makefile rule to produce rt.o:\n$ make rt.o\nThen, you will want to link rt.o and bril.o to produce an executable:\n$ cc bril.o rt.o -o myprog\nIf your Bril @main function takes arguments, those are now command-line arguments to the myprog executable.\n\n\n\nUse the -j flag to compile and run the program immediately:\n$ bril2json &lt; something.bril | brilift -j\nPass any arguments to the Bril @main function as command-line arguments to Brilift. For example, if you have a function @main(foo: int, bar: bool), you can type brilift -j 42 true.\n\n\n\nType brilift --help to see the full list of options:\n\n-j: JIT-compile the code and run it immediately, instead of AOT-compiling an object file (the default).\n-O [none|speed|speed_and_size]: An optimization level, according to Cranelift. The default is none.\n-v: Enable lots of logging from the Cranelift library.\n-d: Dump the Cranelift IR text for debugging.\n\nThese options are only relevant in AOT mode:\n\n-o &lt;FILE&gt;: Place the output object file in &lt;FILE&gt; instead of bril.o (the default).\n-t &lt;TARGET&gt;: Specify the target triple, as interpreted by Cranelift. These triples resemble the target triples that LLVM also understands, for example. For instance, x86_64-unknown-darwin-macho is the triple for macOS on Intel processors."
  },
  {
    "objectID": "src/briltxt/docs/tools/brilift.html#build",
    "href": "src/briltxt/docs/tools/brilift.html#build",
    "title": "Cranelift Compiler",
    "section": "",
    "text": "Brilift is a Rust project using the bril-rs library. You can build it using Cargo:\n$ cd brilift\n$ cargo run -- --help\n$ cargo install --path .  # If you want the executable on your $PATH."
  },
  {
    "objectID": "src/briltxt/docs/tools/brilift.html#ahead-of-time-compilation",
    "href": "src/briltxt/docs/tools/brilift.html#ahead-of-time-compilation",
    "title": "Cranelift Compiler",
    "section": "",
    "text": "Provide the brilift executable with a Bril JSON program:\n$ bril2json &lt; something.bril | brilift\nBy default, Brilift produces a file bril.o. (You can pick your own output filename with -o something.o; see the full list of options below.)\nA complete executable will also need our runtime library, which is in rt.c. There is a convenient Makefile rule to produce rt.o:\n$ make rt.o\nThen, you will want to link rt.o and bril.o to produce an executable:\n$ cc bril.o rt.o -o myprog\nIf your Bril @main function takes arguments, those are now command-line arguments to the myprog executable."
  },
  {
    "objectID": "src/briltxt/docs/tools/brilift.html#just-in-time-compilation",
    "href": "src/briltxt/docs/tools/brilift.html#just-in-time-compilation",
    "title": "Cranelift Compiler",
    "section": "",
    "text": "Use the -j flag to compile and run the program immediately:\n$ bril2json &lt; something.bril | brilift -j\nPass any arguments to the Bril @main function as command-line arguments to Brilift. For example, if you have a function @main(foo: int, bar: bool), you can type brilift -j 42 true."
  },
  {
    "objectID": "src/briltxt/docs/tools/brilift.html#options",
    "href": "src/briltxt/docs/tools/brilift.html#options",
    "title": "Cranelift Compiler",
    "section": "",
    "text": "Type brilift --help to see the full list of options:\n\n-j: JIT-compile the code and run it immediately, instead of AOT-compiling an object file (the default).\n-O [none|speed|speed_and_size]: An optimization level, according to Cranelift. The default is none.\n-v: Enable lots of logging from the Cranelift library.\n-d: Dump the Cranelift IR text for debugging.\n\nThese options are only relevant in AOT mode:\n\n-o &lt;FILE&gt;: Place the output object file in &lt;FILE&gt; instead of bril.o (the default).\n-t &lt;TARGET&gt;: Specify the target triple, as interpreted by Cranelift. These triples resemble the target triples that LLVM also understands, for example. For instance, x86_64-unknown-darwin-macho is the triple for macOS on Intel processors."
  },
  {
    "objectID": "src/briltxt/docs/tools/interp.html",
    "href": "src/briltxt/docs/tools/interp.html",
    "title": "Interpreter",
    "section": "",
    "text": "brili is the reference interpreter for Bril. It is written in TypeScript. You can find brili in the bril-ts directory in the Bril repository.\nThe interpreter supports core Bril along with the memory, floating point, SSA, and speculation extensions.\n\n\nTo use the interpreter, you will need Deno. Just run:\n$ deno install brili.ts\nAs Deno tells you, you will then need to add $HOME/.deno/bin to your $PATH.\nRun\n\nThe brili program takes a Bril program as a JSON file on standard input:\n$ brili &lt; my_program.json\nIt emits any print outputs to standard output. To provide inputs to the main function, you can write them as command-line arguments:\n$ brili 37 5 &lt; add.json\n42\n\n\n\nThe interpreter has a rudimentary profiling mode. Add a -p flag to print out a total number of dynamic instructions executed to stderr:\n$ brili -p 37 5 &lt; add.json\n42\ntotal_dyn_inst: 9"
  },
  {
    "objectID": "src/briltxt/docs/tools/interp.html#install",
    "href": "src/briltxt/docs/tools/interp.html#install",
    "title": "Interpreter",
    "section": "",
    "text": "To use the interpreter, you will need Deno. Just run:\n$ deno install brili.ts\nAs Deno tells you, you will then need to add $HOME/.deno/bin to your $PATH.\nRun\n\nThe brili program takes a Bril program as a JSON file on standard input:\n$ brili &lt; my_program.json\nIt emits any print outputs to standard output. To provide inputs to the main function, you can write them as command-line arguments:\n$ brili 37 5 &lt; add.json\n42"
  },
  {
    "objectID": "src/briltxt/docs/tools/interp.html#profiling",
    "href": "src/briltxt/docs/tools/interp.html#profiling",
    "title": "Interpreter",
    "section": "",
    "text": "The interpreter has a rudimentary profiling mode. Add a -p flag to print out a total number of dynamic instructions executed to stderr:\n$ brili -p 37 5 &lt; add.json\n42\ntotal_dyn_inst: 9"
  },
  {
    "objectID": "src/briltxt/docs/tools/rust.html",
    "href": "src/briltxt/docs/tools/rust.html",
    "title": "Rust Library",
    "section": "",
    "text": "This is a no-frills interface between Bril’s JSON and your Rust code. It supports the Bril core along with the SSA, memory, floating point, speculative execution, char, and source positions extensions.\nUse\n\nInclude this by adding the following to your Cargo.toml:\n[dependencies.bril-rs]\nversion = \"0.1.0\"\npath = \"../bril-rs\"\nfeatures = [\"ssa\", \"memory\", \"float\", \"speculate\", \"position\"]\nEach of the extensions to Bril core is feature gated. To ignore an extension, remove its corresponding string from the features list.\nThere are two helper functions: load_program will read a valid Bril program from stdin, and output_program will write your Bril program to stdout. Otherwise, this library can be treated like any other serde JSON representation.\n\n\nThis library supports fully compatible Rust implementations of bril2txt and bril2json. This library also implements the import extension with a static linker called brild.\nThis library is used in a Rust compiler called rs2bril which supports generating core, float, and memory Bril from a subset of valid Rust.\nThis library is used in a Bril-to-LLVM IR compiler called brillvm which supports core, float, memory, and ssa.\nFor ease of use, these tools can be installed and added to your path by running the following in bril-rs/:\n$ make install\nMake sure that ~/.cargo/bin is on your path. Each of these tools supports the --help flag which specifies some helpful flags.\n\n\n\nTo maintain consistency and cleanliness, run:\ncargo fmt\ncargo clippy\ncargo doc\nmake test\nmake features"
  },
  {
    "objectID": "src/briltxt/docs/tools/rust.html#tools",
    "href": "src/briltxt/docs/tools/rust.html#tools",
    "title": "Rust Library",
    "section": "",
    "text": "This library supports fully compatible Rust implementations of bril2txt and bril2json. This library also implements the import extension with a static linker called brild.\nThis library is used in a Rust compiler called rs2bril which supports generating core, float, and memory Bril from a subset of valid Rust.\nThis library is used in a Bril-to-LLVM IR compiler called brillvm which supports core, float, memory, and ssa.\nFor ease of use, these tools can be installed and added to your path by running the following in bril-rs/:\n$ make install\nMake sure that ~/.cargo/bin is on your path. Each of these tools supports the --help flag which specifies some helpful flags."
  },
  {
    "objectID": "src/briltxt/docs/tools/rust.html#development",
    "href": "src/briltxt/docs/tools/rust.html#development",
    "title": "Rust Library",
    "section": "",
    "text": "To maintain consistency and cleanliness, run:\ncargo fmt\ncargo clippy\ncargo doc\nmake test\nmake features"
  },
  {
    "objectID": "src/briltxt/docs/tools/bench.html",
    "href": "src/briltxt/docs/tools/bench.html",
    "title": "Benchmarks",
    "section": "",
    "text": "Benchmarks\nThe bench directory in the Bril repository contains a fledgling suite of microbenchmarks that you can use to measure the impact of your optimizations. (Benchmarks are different from tests because they are meant to actually calculate something instead of just exercising a language feature.)\nThe current benchmarks are:\n\nackermann: Print the value of Ack(m, n), the two-argument Ackermann–Péter function.\nadj2csr: Convert a graph in adjacency matrix format (dense representation) to Compressed Sparse Row (CSR) format (sparse representation). The random graph is generated using the same linear congruential generator.\nadler32: Computes the Adler-32 Checksum of an integer array.\narmstrong: Determines if the input is an Armstrong number, a number that is the sum of its own digits each raised to the power of the number of digits.\nbinary-fmt: Print the binary format for the given positive integer.\nbinary-search: Search a target integer within an integer array, outputs the index of target.\nbirthday: Simulation of the birthday paradox with an input of n people in a given room.\nbitwise-ops: Computes the OR, AND, or XOR between two 64-bit integers. (Three modes: 0 = AND, 1 = OR, 2 = XOR)\nbitshift: Computes the LEFTSHIFT and RIGHTSHIFT for any integer, also implements an efficient pow function for integers\nbubblesort: Sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.\ncatalan: Print the nth term in the Catalan sequence, compute using recursive function calls.\ncheck-primes: Check the first n natural numbers for primality, printing out a 1 if the number is prime and a 0 if it’s not.\ncholesky: Perform Cholesky decomposition of a Hermitian and positive definite matrix. The result is validated by comparing with Python’s scipy.linalg.cholesky.\ncollatz: Print the Collatz sequence starting at n. Note: it is not known whether this will terminate for all n.\nconjugate-gradient: Uses conjugate gradients to solve Ax=b for any arbitrary positive semidefinite A.\ncordic: Print an approximation of sine(radians) using 8 iterations of the CORDIC algorithm.\ncsrmv: Multiply a sparse matrix in the Compressed Sparse Row (CSR) format with a dense vector. The matrix and input vector are generated using a Linear Feedback Shift Register random number generator.\ndigial-root: Computes the digital root of the input number.\ndead-branch: Repeatedly call a br instruction whose condition always evaluates to false. The dead branch should be pruned by a smart compiler.\ndot-product: Computes the dot product of two vectors.\neight-queens: Counts the number of solutions for n queens problem, a generalization of Eight queens puzzle.\neuclid: Calculates the greatest common divisor between two large numbers using the Euclidean Algorithm with a helper function for the modulo operator.\neuler: Approximates Euler’s number using the Taylor series.\nfact: Prints the factorial of n, computing it recursively.\nfactors: Print the factors of the n using the trial division method.\nfib: Calculate the nth Fibonacci number by allocating and filling an array of numbers up to that point.\nfizz-buzz: The infamous programming test.\nfunction_call: For benchmarking the overhead of simple function calls.\ngcd: Calculate Greatest Common Divisor (GCD) of two input positive integer using Euclidean algorithm.\nhanoi: Print the solution to the n-disk Tower of Hanoi puzzle.\nis-decreasing: Print if a number contains strictly decreasing digits.\nlcm: Compute LCM for two numbers using a very inefficient loop.\nloopfact: Compute n! imperatively using a loop.\nmajor-elm: Find the majority element in an array using a linear time voting algorithm.\nmandelbrot: Generates a really low resolution, ascii, mandelbrot set.\nmat-inv : Calculates the inverse of a 3x3 matrix and prints it out.\nmat-mul: Multiplies two nxn matrices using the naive matrix multiplication algorithm. The matrices are randomly generated using a linear congruential generator.\nmax-subarray: solution to the classic Maximum Subarray problem.\nmod_inv: Calculates the modular inverse of n under to a prime modulus p.\nnewton: Calculate the square root of 99,999 using the newton method\nnorm: Calculate the euclidean norm of a vector\nn_root: Calculate nth root of a float using newton’s method.\norders: Compute the order ord(u) for each u in a cyclic group &lt;Zn,+&gt; of integers modulo n under the group operation + (modulo n). Set the second argument is_lcm to true if you would like to compute the orders using the lowest common multiple and otherwise the program will use the greatest common divisor.\npascals-row: Computes a row in Pascal’s Triangle.\npalindrome: Outputs a 0-1 value indicating whether the input is a palindrome number.\nperfect: Check if input argument is a perfect number. Returns output as Unix style return code.\npow: Computes the n^th power of a given (float) number.\nprimes-between: Print the primes in the interval [a, b].\nprimitive-root: Computes a primitive root modulo a prime number input.\npythagorean_triple: Prints all Pythagorean triples with the given c, if such triples exist. An intentionally very naive implementation.\nquadratic: The quadratic formula, including a hand-rolled implementation of square root.\nquickselect: Find the kth smallest element in an array using the quickselect algorithm.\nquicksort: Quicksort using the Lomuto partition scheme.\nquicksort-hoare: Quicksort using Hoare partioning and median of three pivot selection.\nrecfact: Compute n! using recursive function calls.\nrectangles-area-difference: Output the difference between the areas of rectangles (as a positive value) given their respective side lengths.\nfitsinside: Output whether or not a rectangle fits inside of another rectangle given the width and height lengths.\nrelative-primes: Print all numbers relatively prime to n using Euclidean algorithm.\nriemann: Prints the left, midpoint, and right Riemann Sums for a specified function, which is the square function in this benchmark.\nsieve: Print all prime numbers up to n using the Sieve of Eratosthenes.\nsqrt: Implements the Newton–Raphson Method of approximating the square root of a number to arbitrary precision\nsum-bit: Print the number of 1-bits in the binary representation of the input integer.\nsum-check: Compute the sum of [1, n] by both loop and formula, and check if the result is the same.\nsum-divisors: Prints the positive integer divisors of the input integer, followed by the sum of the divisors.\nsum-sq-diff: Output the difference between the sum of the squares of the first n natural numbers and the square of their sum.\ntotient: Computes Euler’s totient function on an input integer n.\ntwo-sum: Print the indices of two distinct elements in the list [2, 7, 11, 13] whose sum equals the input.\nup-arrow: Computes Knuth’s up arrow notation, with the first argument being the number, the second argument being the number of Knuth’s up arrows, and the third argument being the number of repeats.\nvsmul: Multiplies a constant scalar to each element of a large array. Tests the performance of vectorization optimizations.\nreverse: Compute number with reversed digits (e.g. 123 -&gt; 321).\n\nCredit for several of these benchmarks goes to Alexa VanHattum and Gregory Yauney, who implemented them for their global value numbering project.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "src/briltxt/docs/tools/brilirs.html",
    "href": "src/briltxt/docs/tools/brilirs.html",
    "title": "Fast Interpreter in Rust",
    "section": "",
    "text": "The brilirs directory contains a fast Bril interpreter written in Rust. It is a drop-in replacement for the reference interpreter that prioritizes speed over completeness and hackability. It implements core Bril along with the SSA, memory, char, and floating point extensions.\nRead more about the implementation, which is originally by Wil Thomason and Daniel Glus.\n\n\nTo use brilirs you will need to install Rust. Use echo $PATH to check that $HOME/.cargo/bin is on your path.\nIn the brilirs directory, install the interpreter with:\n$ cargo install --path .\nDuring installation, brilirs will attempt to create a tab completions file for current shell. If this of interest, follow the instructions provided as a warning to finish enabling this.\nRun a program by piping a JSON Bril program into it:\n$ bril2json &lt; myprogram.bril | brilirs\nor\n$ brilirs --text --file myprogram.bril\nSimilar to brilck, brilirs can be used to typecheck and validate your Bril JSON program by passing the --check flag (similar to cargo --check).\nTo see all of the supported flags, run:\n$ brilirs --help"
  },
  {
    "objectID": "src/briltxt/docs/tools/brilirs.html#install",
    "href": "src/briltxt/docs/tools/brilirs.html#install",
    "title": "Fast Interpreter in Rust",
    "section": "",
    "text": "To use brilirs you will need to install Rust. Use echo $PATH to check that $HOME/.cargo/bin is on your path.\nIn the brilirs directory, install the interpreter with:\n$ cargo install --path .\nDuring installation, brilirs will attempt to create a tab completions file for current shell. If this of interest, follow the instructions provided as a warning to finish enabling this.\nRun a program by piping a JSON Bril program into it:\n$ bril2json &lt; myprogram.bril | brilirs\nor\n$ brilirs --text --file myprogram.bril\nSimilar to brilck, brilirs can be used to typecheck and validate your Bril JSON program by passing the --check flag (similar to cargo --check).\nTo see all of the supported flags, run:\n$ brilirs --help"
  },
  {
    "objectID": "src/briltxt/docs/tools/ts.html",
    "href": "src/briltxt/docs/tools/ts.html",
    "title": "TypeScript Library",
    "section": "",
    "text": "TypeScript Library\nbril-ts is a TypeScript library for interacting with Bril programs. It is the basis for the reference interpreter and the included type checker, but it is also useful on its own.\nThe library includes:\n\nbril.ts: Type definitions for the Bril language. Parsing a JSON file produces a value of type Program from this module.\nbuilder.ts: A builder class that makes it more convenient to generate Bril programs from front-end compilers.\ntypes.ts: A description of the type signatures for Bril operations, including the core language and all currently known extensions.\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "notebooks/bril.html",
    "href": "notebooks/bril.html",
    "title": "overview of Bril",
    "section": "",
    "text": "How to use Bril with real code\nBril is very simple, very regular, ir. Bril can be extended easily.\nBril has lots of tools and examples.\nlets look at a bril program.\nBril is written in JSON format. Almost all programming languages have a way to read json.\n\nimport json\nimport subprocess\nimport os \n\nwith open(\"tests/add.json\", \"r\") as f:\n    bril_program = json.load(f)\n\n# print the json with nice indenting\nprint(json.dumps(bril_program, indent=2))\n\n{\n  \"functions\": [\n    {\n      \"name\": \"main\",\n      \"instrs\": [\n        {\n          \"op\": \"const\",\n          \"type\": \"int\",\n          \"dest\": \"v0\",\n          \"value\": 1\n        },\n        {\n          \"op\": \"const\",\n          \"type\": \"int\",\n          \"dest\": \"v1\",\n          \"value\": 2\n        },\n        {\n          \"op\": \"add\",\n          \"type\": \"int\",\n          \"dest\": \"v2\",\n          \"args\": [\n            \"v0\",\n            \"v1\"\n          ]\n        },\n        {\n          \"op\": \"print\",\n          \"args\": [\n            \"v2\"\n          ]\n        }\n      ],\n      \"args\": []\n    }\n  ]\n}\n\n\n{\n  \"functions\": [\n    {\n      \"name\": \"main\",\n      \"instrs\": [\n        { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v0\", \"value\": 1 },\n        { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v1\", \"value\": 2 },\n        { \"op\": \"add\", \"type\": \"int\", \"dest\": \"v2\",\n          \"args\": [\"v0\", \"v1\"] },\n        { \"op\": \"print\", \"args\": [\"v2\"] }\n      ],\n      \"args\": []\n    }\n  ]\n}\nThere is also a text form which is more readable\nwe have program bril2txt and bril2json that make it easy to convert. Keep in mind that the json format is Bril and thats where you will do all the work.\n\nimport os \nos.system(\"bril2txt &lt; tests/add.json\")\n\n@main {\n  v0: int = const 1;\n  v1: int = const 2;\n  v2: int = add v0 v1;\n  print v2;\n}\n\n\n0\n\n\n\n!bril2txt &lt; tests/add.json\n\n@main {\n  v0: int = const 1;\n  v1: int = const 2;\n  v2: int = add v0 v1;\n  print v2;\n}\n\n\n\n# you can connect tools via pipes \nos.system(\"bril2txt &lt; tests/add.json | bril2json\")\n\n{\n  \"functions\": [\n    {\n      \"instrs\": [\n        {\n          \"dest\": \"v0\",\n          \"op\": \"const\",\n          \"type\": \"int\",\n          \"value\": 1\n        },\n        {\n          \"dest\": \"v1\",\n          \"op\": \"const\",\n          \"type\": \"int\",\n          \"value\": 2\n        },\n        {\n          \"args\": [\n            \"v0\",\n            \"v1\"\n          ],\n          \"dest\": \"v2\",\n          \"op\": \"add\",\n          \"type\": \"int\"\n        },\n        {\n          \"args\": [\n            \"v2\"\n          ],\n          \"op\": \"print\"\n        }\n      ],\n      \"name\": \"main\"\n    }\n  ]\n}\n\n\n0\n\n\nBril tools were mostly student projects, as you think about your projects, you might consider adding a new tool. you can setup Bril on your local linux (wsl) machine by cloning the bril github and installing all the tools\n\n# Bril has an interpreter which reads in json and output the result\n\nos.system(f'brili &lt;tests/add.json')\n\n3\n\n\n0\n\n\nLets write a sample program - generating the cfg\nI’ll do this in two steps 1) find all the basic blocks 2) add all the cfg edges\nfinding the basic blocks from a list of instructions-\nkeep adding instructions till we get to a terminator or a label (do we add labels?)\nin: list of instrs \nout: list of lists of instrs \n\nblocks = []\ncurr_block = []\nfor each instr in list \n   if the instruction is not a label put it on curr_block\n   if instr is a label or terminator \n      put curr_block on blocks\n      curr_block = []\n\nif curr_block is not empty add it to blocks\nreturn blocks \nfind cfg: in is bril progmam in json \nfor each function find the list of instructions \n    get last_instr \n    if it is a terminator  br/jmp/ret  \n    --- what do we want to do with call? \n    else it is a fall through\nwe need a map (block_map) label-&gt;block so we can add edges for blocks that end in br/jmp - can build this while getting the blocks or we can put the label as the first instruction\nhow do we get fall through?\nwhat about a return\nif every block ends with a terminator, and every block has a label, then no fall through case what happens if try to delete the terminator (because the block never executes)\nI’ll use a python data structure called OrderedDict, when you iterate over the items in a ordered dict, they come back in the order that they were installed.\n\n# playing around with hacking- I'll use a generator \n\n\n#Instructions that terminate a basic block.\nTERMINATORS = 'br', 'jmp', 'ret'\n\n\ndef form_blocks(instrs):\n    \"\"\"Given a list of Bril instructions, generate a sequence of\n    instruction lists representing the basic blocks in the program.\n\n    Every instruction in `instr` will show up in exactly one block. Jump\n    and branch instructions may only appear at the end of a block, and\n    control can transfer only to the top of a basic block---so labels\n    can only appear at the *start* of a basic block. Basic blocks may\n    not be empty.\n    \"\"\"\n\n    # Start with an empty block.\n    cur_block = []\n\n    for instr in instrs:\n        if 'op' in instr:  # It's an instruction.\n            # Add the instruction to the currently-being-formed block.\n            cur_block.append(instr)\n\n            # If this is a terminator (branching instruction), it's the\n            # last instruction in the block. Finish this block and\n            # start a new one.\n            if instr['op'] in TERMINATORS:\n                yield cur_block\n                cur_block = []\n\n        else:  # It's a label.\n            # End the block here (if it contains anything).\n            if cur_block:\n                yield cur_block\n\n            # Start a new block with the label.\n            cur_block = [instr]\n\n    # Produce the final block, if any.\n    if cur_block:\n        yield cur_block\n\n\ndef print_blocks(bril):\n    \"\"\"Given a Bril program, print out its basic blocks.\n    \"\"\"\n\n\n    func = bril['functions'][0]  # We only process one function.\n    for block in form_blocks(func['instrs']):\n        # Mark the block.\n        leader = block[0]\n        if 'label' in leader:\n            print( f\"block {leader['label']}\")\n            block = block[1:]  # Hide the label, for concision.\n        else:\n            print('anonymous block:')\n\n        # Print the instructions.\n        for instr in block:\n            print(instr)\n\n\nprint_blocks(bril_program)\n\nanonymous block:\n{'op': 'const', 'type': 'int', 'dest': 'v0', 'value': 1}\n{'op': 'const', 'type': 'int', 'dest': 'v1', 'value': 2}\n{'op': 'add', 'type': 'int', 'dest': 'v2', 'args': ['v0', 'v1']}\n{'op': 'print', 'args': ['v2']}\n\n\n\nwith open(\"tests/jmp.bril\", 'r') as f:\n          test2 = f.read()\n\nprint(test2)\n\n\nresult = subprocess.check_output('bril2json &lt;tests/jmp.bril', shell=True)\n\ntest2json = json.loads(result)\nprint(test2json)\n\n@main {\n  v: int = const 4;\n  jmp .somewhere;\n  v: int = const 2;\n.somewhere:\n  print v;\n}\n\n{'functions': [{'instrs': [{'dest': 'v', 'op': 'const', 'type': 'int', 'value': 4}, {'labels': ['somewhere'], 'op': 'jmp'}, {'dest': 'v', 'op': 'const', 'type': 'int', 'value': 2}, {'label': 'somewhere'}, {'args': ['v'], 'op': 'print'}], 'name': 'main'}]}\n\n\n\nprint_blocks(test2json['functions'][0])\n\nKeyError: 'functions'\n\n\n\n# now for the map \nfrom collections import OrderedDict\n\n\ndef block_map(blocks):\n    \"\"\"Given a sequence of basic blocks, which are lists of instructions,\n    produce a `OrderedDict` mapping names to blocks.\n\n    The name of the block comes from the label it starts with, if any.\n    Anonymous blocks, which don't start with a label, get an\n    automatically generated name. Blocks in the mapping have their\n    labels removed.\n    \"\"\"\n    by_name = OrderedDict()\n\n    for block in blocks:\n        # Generate a name for the block.\n        if 'label' in block[0]:\n            # The block has a label. Remove the label but use it for the\n            # block's name.\n            name = block[0]['label']\n            block = block[1:]\n        else:\n            # Make up a new name for this anonymous block.\n            name = f'gen_bk_{len(by_name)}'\n\n        # Add the block to the mapping.\n        by_name[name] = block\n\n    return by_name\n\n\nblks = form_blocks(test2json['functions'][0]['instrs'])\nod = block_map(blks)\nfor (name, instrs) in od.items():\n    print (name, instrs)\n\ngen_bk_0 [{'dest': 'v', 'op': 'const', 'type': 'int', 'value': 4}, {'labels': ['somewhere'], 'op': 'jmp'}]\ngen_bk_1 [{'dest': 'v', 'op': 'const', 'type': 'int', 'value': 2}]\nsomewhere [{'args': ['v'], 'op': 'print'}]\n\n\n\nfinally the cfg\nout cfg = {} map label -&gt; list of labels the successors of the block\n\nfor i , block in enumerate(blocks)  # blocks is a ordereddict \n  last = block[i]  # last instruction\n  if last is jmp:\n     cfg[block_name] = jmp.dest\n  elif last is br:\n    cfg[block.name] = [ last.if_label, last.else_label]\n  else\n     # fall through\n    cfg[block_name = blocks[i+1].name  ## special case for last block\n\ndef get_cfg(ordered_blocks):\n    cfg = {}\n\n    labels = list(ordered_blocks.keys())\n\n    for i, (block_name, block) in enumerate(ordered_blocks.items()):\n        last = block[-1]\n        op = last['op']\n\n        if op == 'jmp':\n            cfg[block_name] = last['labels']\n        elif op == 'br':\n            cfg[block_name] = last['labels']\n        else:\n            if i+1 &lt; len(labels):  # last block does not fall through\n                cfg[block_name] = [labels[i+1]]\n    return cfg\n\n\nblks = form_blocks(test2json['functions'][0]['instrs'])\nod = block_map(blks)\ncfg = get_cfg(od)\n\nprint(cfg)\n\n{'gen_bk_0': ['somewhere'], 'gen_bk_1': ['somewhere']}\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EECE7398 Fall 2024",
    "section": "",
    "text": "EECS 7398 Fall 2024\nInstructor: Dr. Norman Rubin\nemail: n.rubin@northeastern.edu\n\n\n\n\n\n\nWarning\n\n\n\nOffice hours: TBA\nWhere TBA\nOffice hours by appointment\n\n\nI’m basing a lot of this course on the cs120 Advanced Compilers at Cornell. Thanks to Adrian Sampson for permission to use his stuff. You may find his web site helpful.\nYou can see videos of Adrian’s lectures\n\n\n\n Back to top"
  },
  {
    "objectID": "Class_Overview/schedule.html",
    "href": "Class_Overview/schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Caution\n\n\n\nWhere do we discussions\nThis actualy the sylibus - needs weekly dates for a schedule, and paper list\n\n\n\n\n\nWeek\nTopic\nlectures\nDiscussion\n\n\n\n\n1\nCompiler overview and structure\nlecture\n???\n\n\n\nPerformance Measurement\nlecture\n???\n\n\n2\nRepresenting programs\nlecture\n???\n\n\n\nOverview of Bril\nnotebook\n???\n\n\n3\nLocal analysis and optimization\nlecture\n???\n\n\n4\nData flow\nlecture\n???\n\n\n5\nGlobal analysis\nlecture\n???\n\n\n6\nStatic single assignment\nlecture\n???\n\n\n7\nLLVM\nlecture\n???\n\n\n8\nClassical loop optimizations\nlecture\n???\n\n\n9\nPolyhedral analysis\nlecture\n???\n\n\n10\nMLIR\nlecture\n???\n\n\n11\nInterprocedural Analysis\nlecture\n???\n\n\n12\nMemory Management\nlecture\n???\n\n\n13\nDynamic compilers\nlecture\n???\n\n\n14\nGPU Compilers\nlecture\n???\n\n\n\nPapers\n\n\n\n\n\n\nCaution\n\n\n\nlist of papers and dates for student presentations\n\n\n\n\n\n Back to top",
    "crumbs": [
      "EECS 7398",
      "Class Overview",
      "Schedule"
    ]
  },
  {
    "objectID": "Class_Overview/about.html",
    "href": "Class_Overview/about.html",
    "title": "About",
    "section": "",
    "text": "This is the web site for eece 7398\n\n\n\n\n\n\nWarning\n\n\n\nfill in the about page\n\n\n\n\n\n Back to top",
    "crumbs": [
      "EECS 7398",
      "Class Overview",
      "About"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\n\n Back to top"
  },
  {
    "objectID": "notebooks/representation.html",
    "href": "notebooks/representation.html",
    "title": "Representation",
    "section": "",
    "text": "The representation of a program - is what we read in and read out when transforming a program. What kind of properties make a good representation?\nOne possible representation is called concrete syntax form Programs are text - surface syntax- just what you would type into an editor.\n\nvalue = 8\nresult = 1\nfor i in range(value):\n  result = result + i\nprint(result)\n\n29\n\n\nWhat is good and what is bad about this representation?\nWhat is the level of abstraction? How do you understand the semantics.\nForm 2 - Abstract syntax form\nTree structure - Nodes are parts of the program, edges show how they are connected. We can write this as a list or a graph\n\n\nFunctionDef(\n    name='pgm',\n    args=arguments(\n        posonlyargs=[],\n        args=[],\n        kwonlyargs=[],\n        kw_defaults=[],\n        defaults=[]),\n    body=[\n        Assign(\n            targets=[\n                Name(id='value', ctx=Store())],\n            value=Constant(value=8)),\n        Assign(\n            targets=[\n                Name(id='result', ctx=Store())],\n            value=Constant(value=1)),\n        For(\n            target=Name(id='i', ctx=Store()),\n            iter=Call(\n                func=Name(id='range', ctx=Load()),\n                args=[\n                    Name(id='value', ctx=Load())],\n                keywords=[]),\n            body=[\n                Assign(\n                    targets=[\n                        Name(id='result', ctx=Store())],\n                    value=BinOp(\n                        left=Name(id='result', ctx=Load()),\n                        op=Mult(),\n                        right=Name(id='i', ctx=Load())))],\n            orelse=[]),\n        Expr(\n            value=Call(\n                func=Name(id='print', ctx=Load()),\n                args=[\n                    Name(id='result', ctx=Load())],\n                keywords=[]))],\n    decorator_list=[])\n\n\n\ndot_dia\n\n\n\n\n\n\n\n\nAST tree representation An AST is a tree structure, nodes like if, test, body, assign Each node is one concept from the program\nRecursive function can walk over the tree, one chunk of code for each node.\n\nGood - each type of node is different, making special cases are easy\nBad - each type of node is different so analysis has to know about every type, making general cases hard\n\nThis is the classic way to write an interpreter. Simple (non optimizing) compilers often use this format.\n\n\nPrograms are lists of instructions. Like an assembly instructions. Same sort of representation as LLVM.\n\n\n    let value = 8\n    let result = 1\n    for (let i = 0;i &lt; value;i = i+ 1)\n    {\n        result = result * i\n    }\n    console.log(result )\n\n\n\n@main {\n  v0: float = const 8;\n  value: float = id v0;\n  v1: float = const 1;\n  result: float = id v1;\n  v3: float = const 0;\n  i: float = id v3;\n.for.cond.2:\n  v4: float = id i;\n  v5: float = id value;\n  v6: bool = flt v4 v5;\n  br v6 .for.body.2 .for.end.2;\n.for.body.2:\n  v7: float = id result;\n  v8: float = id i;\n  v9: float = fmul v7 v8;\n  result: float = id v9;\n  v10: float = id i;\n  v11: float = const 1;\n  v12: float = fadd v10 v11;\n  i: float = id v12;\n  jmp .for.cond.2;\n.for.end.2:\n  v13: float = id result;\n  print v13;\n  v14: int = const 0;\n}\n\n\n\n\nos.system('ts2bril images/toy.ts | bril2txt')\n\n@main {\n  v0: float = const 8;\n  value: float = id v0;\n  v1: float = const 1;\n  result: float = id v1;\n  v3: float = const 0;\n  i: float = id v3;\n.for.cond.2:\n  v4: float = id i;\n  v5: float = id value;\n  v6: bool = flt v4 v5;\n  br v6 .for.body.2 .for.end.2;\n.for.body.2:\n  v7: float = id result;\n  v8: float = id i;\n  v9: float = fmul v7 v8;\n  result: float = id v9;\n  v10: float = id i;\n  v11: float = const 1;\n  v12: float = fadd v10 v11;\n  i: float = id v12;\n  jmp .for.cond.2;\n.for.end.2:\n  v13: float = id result;\n  print v13;\n  v14: int = const 0;\n}\n\n\n0\n\n\nLooks like assembly but no limit on registers, no condition codes. fully typed, no complex addressing modes.\nsyntax-\nDeclare functions, labels, instructions\ninstruction:\n1) variable type = opcode arguments 2) opcode list of arguments\n\n\n\nWhat is the abstract syntax form for this?\n\n\n\n\n\nRepresentation is a directed graph. Nodes are instructions, edges indicate possible flow of control, one entry and one exit node.\nHere is a simple program:\n    @main {\n        v: int = const 5;\n        print v;\n    }\n\n\n\n\n\nflowchart LR\n  A[const] --&gt; B[print]\n\n\n\n\n\n\na second example\n    @main {\n        v: int = const 4;\n        jmp  .somewhere;\n        v: int = const 2;\n        .somewhere;\n        print v;\n    }\nWhat does the control flow graph look like?\n\n\n\n\n\nflowchart LR\n  A[const 4] --&gt; B[jmp]\n  B --&gt; C[print]\n  D[const 2] --&gt; C\n\n\n\n\n\n\nnotice label does not produce a node\nEasy to see a dead instruction.\nThird example:\n    @main {\n        v: int = const 4;\n        b: bool = const false;\n        br b .there .here;\n    .here:\n        v: int = const 2;\n    .there;\n        print v;\n    }\n\n\n\n\n\nflowchart LR\n  A[v: int const 4] --&gt; B[b: bool const false]\n  B --&gt; C[br b .there, .false]\n  C --&gt; D[v: const 2]\n  C --&gt; E[print v]\n  D --&gt; E\n\n\n\n\n\n\nwhich is the true and which is the false, could mark the edges or use a convention\nWhich is the entry, which is the exit?\nThere is a long chain of instructions entered at the top, exit at the bottom, no branches inside.\nBasic blocks (cfg form 2) 1) nodes can be a sequence of instructions. 1) jumps and branches can only be at the end of a sequence 1) only label has to be at the start 1) every instruction in the sequence executes the same number of times\n\n\n\n\n\nflowchart LR\n  A[v: int const 4\\nb : bool\\n br ] \n  A --&gt; D[v: const 2]\n  A --&gt; E[print v]\n  D --&gt; E\n\n\n\n\n\n\nAs we construct basic blocks, we can add instructions up till something that ends the block (terminator)\nOption: do all blocks end in a terminator or not?\ngiven a block b, the predecessors of b are the blocks b_in where there is an edge bin-&gt;b. And the successors of B are the b_out where b-&gt;b_out is an edge\n\n\n\n\n\njust find all the basic blocks\nadd the control flow edges\n\npsuedo code\n\nin: instructions - list of instructions\nout blocks - list of lists of instructions\n\ncurrent_block = []\nfor i in instructions:\n    if i is not a label:\n       block.append(i)\n    if i is a label or terminator:\n        blocks.append(current_block)\n        current_block = []\nstep 2 we need a map from labels to basic blocks\n\nin: instructions - list of instructions\nout blocks - list of lists of instructions\n\ncurrent_block = []\nfor i in instructions:\n    if i is not a label:\n       block.append(i)\n    if i is a label or terminator:\n        blocks.append(current_block)\n        current_block = []\n    \n\nfor block in blocks:\n   last = block[-1]\n   if last is a jmp (one successor)\n      add edge from block to last.dest \n   else if last is a br (two successors)\n      add two edges from block to last.true, last.false \n   else  fall through \n      add edge to next block (if it exists)\n\nwith open(\"images/add.json\", 'r') as f:\n  bril_program = f.read()\n  print(bril_program)\n\n{\n  \"functions\": [\n    {\n      \"name\": \"main\",\n      \"instrs\": [\n        { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v0\", \"value\": 1 },\n        { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v1\", \"value\": 2 },\n        { \"op\": \"add\", \"type\": \"int\", \"dest\": \"v2\",\n          \"args\": [\"v0\", \"v1\"] },\n        { \"op\": \"print\", \"args\": [\"v2\"] }\n      ],\n      \"args\": []\n    }\n  ]\n}"
  },
  {
    "objectID": "notebooks/representation.html#a-more-regular-representation",
    "href": "notebooks/representation.html#a-more-regular-representation",
    "title": "Representation",
    "section": "",
    "text": "Programs are lists of instructions. Like an assembly instructions. Same sort of representation as LLVM.\n\n\n    let value = 8\n    let result = 1\n    for (let i = 0;i &lt; value;i = i+ 1)\n    {\n        result = result * i\n    }\n    console.log(result )\n\n\n\n@main {\n  v0: float = const 8;\n  value: float = id v0;\n  v1: float = const 1;\n  result: float = id v1;\n  v3: float = const 0;\n  i: float = id v3;\n.for.cond.2:\n  v4: float = id i;\n  v5: float = id value;\n  v6: bool = flt v4 v5;\n  br v6 .for.body.2 .for.end.2;\n.for.body.2:\n  v7: float = id result;\n  v8: float = id i;\n  v9: float = fmul v7 v8;\n  result: float = id v9;\n  v10: float = id i;\n  v11: float = const 1;\n  v12: float = fadd v10 v11;\n  i: float = id v12;\n  jmp .for.cond.2;\n.for.end.2:\n  v13: float = id result;\n  print v13;\n  v14: int = const 0;\n}\n\n\n\n\nos.system('ts2bril images/toy.ts | bril2txt')\n\n@main {\n  v0: float = const 8;\n  value: float = id v0;\n  v1: float = const 1;\n  result: float = id v1;\n  v3: float = const 0;\n  i: float = id v3;\n.for.cond.2:\n  v4: float = id i;\n  v5: float = id value;\n  v6: bool = flt v4 v5;\n  br v6 .for.body.2 .for.end.2;\n.for.body.2:\n  v7: float = id result;\n  v8: float = id i;\n  v9: float = fmul v7 v8;\n  result: float = id v9;\n  v10: float = id i;\n  v11: float = const 1;\n  v12: float = fadd v10 v11;\n  i: float = id v12;\n  jmp .for.cond.2;\n.for.end.2:\n  v13: float = id result;\n  print v13;\n  v14: int = const 0;\n}\n\n\n0\n\n\nLooks like assembly but no limit on registers, no condition codes. fully typed, no complex addressing modes.\nsyntax-\nDeclare functions, labels, instructions\ninstruction:\n1) variable type = opcode arguments 2) opcode list of arguments"
  },
  {
    "objectID": "notebooks/representation.html#what-is-good-and-what-is-about-this-reorientation",
    "href": "notebooks/representation.html#what-is-good-and-what-is-about-this-reorientation",
    "title": "Representation",
    "section": "",
    "text": "What is the abstract syntax form for this?"
  },
  {
    "objectID": "notebooks/representation.html#extract-info-from-this-repreentation.",
    "href": "notebooks/representation.html#extract-info-from-this-repreentation.",
    "title": "Representation",
    "section": "",
    "text": "Representation is a directed graph. Nodes are instructions, edges indicate possible flow of control, one entry and one exit node.\nHere is a simple program:\n    @main {\n        v: int = const 5;\n        print v;\n    }\n\n\n\n\n\nflowchart LR\n  A[const] --&gt; B[print]\n\n\n\n\n\n\na second example\n    @main {\n        v: int = const 4;\n        jmp  .somewhere;\n        v: int = const 2;\n        .somewhere;\n        print v;\n    }\nWhat does the control flow graph look like?\n\n\n\n\n\nflowchart LR\n  A[const 4] --&gt; B[jmp]\n  B --&gt; C[print]\n  D[const 2] --&gt; C\n\n\n\n\n\n\nnotice label does not produce a node\nEasy to see a dead instruction.\nThird example:\n    @main {\n        v: int = const 4;\n        b: bool = const false;\n        br b .there .here;\n    .here:\n        v: int = const 2;\n    .there;\n        print v;\n    }\n\n\n\n\n\nflowchart LR\n  A[v: int const 4] --&gt; B[b: bool const false]\n  B --&gt; C[br b .there, .false]\n  C --&gt; D[v: const 2]\n  C --&gt; E[print v]\n  D --&gt; E\n\n\n\n\n\n\nwhich is the true and which is the false, could mark the edges or use a convention\nWhich is the entry, which is the exit?\nThere is a long chain of instructions entered at the top, exit at the bottom, no branches inside.\nBasic blocks (cfg form 2) 1) nodes can be a sequence of instructions. 1) jumps and branches can only be at the end of a sequence 1) only label has to be at the start 1) every instruction in the sequence executes the same number of times\n\n\n\n\n\nflowchart LR\n  A[v: int const 4\\nb : bool\\n br ] \n  A --&gt; D[v: const 2]\n  A --&gt; E[print v]\n  D --&gt; E\n\n\n\n\n\n\nAs we construct basic blocks, we can add instructions up till something that ends the block (terminator)\nOption: do all blocks end in a terminator or not?\ngiven a block b, the predecessors of b are the blocks b_in where there is an edge bin-&gt;b. And the successors of B are the b_out where b-&gt;b_out is an edge"
  },
  {
    "objectID": "notebooks/representation.html#what-is-an-algorithm-that-forms-a-cfg",
    "href": "notebooks/representation.html#what-is-an-algorithm-that-forms-a-cfg",
    "title": "Representation",
    "section": "",
    "text": "just find all the basic blocks\nadd the control flow edges\n\npsuedo code\n\nin: instructions - list of instructions\nout blocks - list of lists of instructions\n\ncurrent_block = []\nfor i in instructions:\n    if i is not a label:\n       block.append(i)\n    if i is a label or terminator:\n        blocks.append(current_block)\n        current_block = []\nstep 2 we need a map from labels to basic blocks\n\nin: instructions - list of instructions\nout blocks - list of lists of instructions\n\ncurrent_block = []\nfor i in instructions:\n    if i is not a label:\n       block.append(i)\n    if i is a label or terminator:\n        blocks.append(current_block)\n        current_block = []\n    \n\nfor block in blocks:\n   last = block[-1]\n   if last is a jmp (one successor)\n      add edge from block to last.dest \n   else if last is a br (two successors)\n      add two edges from block to last.true, last.false \n   else  fall through \n      add edge to next block (if it exists)\n\nwith open(\"images/add.json\", 'r') as f:\n  bril_program = f.read()\n  print(bril_program)\n\n{\n  \"functions\": [\n    {\n      \"name\": \"main\",\n      \"instrs\": [\n        { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v0\", \"value\": 1 },\n        { \"op\": \"const\", \"type\": \"int\", \"dest\": \"v1\", \"value\": 2 },\n        { \"op\": \"add\", \"type\": \"int\", \"dest\": \"v2\",\n          \"args\": [\"v0\", \"v1\"] },\n        { \"op\": \"print\", \"args\": [\"v2\"] }\n      ],\n      \"args\": []\n    }\n  ]\n}"
  },
  {
    "objectID": "src/briltxt/docs/tools/plugin.html",
    "href": "src/briltxt/docs/tools/plugin.html",
    "title": "Syntax Plugin for Text Editors",
    "section": "",
    "text": "Syntax Plugin for Text Editors\nThere is a Vim syntax highlighting plugin for Bril’s text format available in bril-vim. You can use it with a Vim plugin manager. For example, if you use vim-plug, you can add this to your .vimrc:\nPlug 'sampsyo/bril', { 'for': 'bril', 'rtp': 'bril-vim' }\nYou can read more about the plugin, which is originally by Edwin Peguero.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "src/briltxt/docs/tools/swift.html",
    "href": "src/briltxt/docs/tools/swift.html",
    "title": "Swift Library",
    "section": "",
    "text": "Swift Library\nThe Swift bril library, which lives in the bril-swift directory, provides a Swift interface for Bril’s JSON files. It supports the Bril core and the SSA extension.\nUse\n\nTo use this package in a SwiftPM project, add a dependency to your Package.swift:\nlet package = Package(\n  name: \"MyPackage\",\n  dependencies: [\n    .package(name: \"Bril\", path: \"../bril-swift\"),\n  ]\n)\nand add \"Bril\" to the dependencies array for any target that needs it:\ntargets: [\n    .target(\n        name: \"MyTarget\",\n        dependencies: [\"Bril\"]),\n// ...\nThe Bril objects conform to Decodable. Instantiate a program from data as follows:\nimport Bril\n\n/// to read from stdin:\n/// let data = FileHandle.standardInput.availableData\n\n/// or from a string:\n/// let data = \"&lt;Bril JSON&gt;\".data(using: .utf8)!\n\nlet program = try JSONDecoder().decode(Program.self, from: data)\nThe models conform to CustomStringConvertible so printing the Bril representation is simply:\nprint(program)\n\n\n\n\n Back to top"
  },
  {
    "objectID": "src/briltxt/docs/tools/ts2bril.html",
    "href": "src/briltxt/docs/tools/ts2bril.html",
    "title": "TypeScript-to-Bril Compiler",
    "section": "",
    "text": "Bril comes with a compiler from a very small subset of TypeScript to Bril called ts2bril.\nIt is not supposed to make it easy to port existing JavaScript code to Bril; it is a convenient way to write larger, more interesting programs without manually fiddling with Bril directly. It also emits somewhat obviously inefficient code to keep the compiler simple; some obvious optimizations can go a long way.\n\n\nThe TypeScript compiler uses Deno. Type this:\n$ deno install --allow-env --allow-read ts2bril.ts\nIf you haven’t already, you will then need to add $HOME/.deno/bin to [your $PATH][path].\nUse\n\nCompile a TypeScript program to Bril by giving a filename on the command line:\n$ ts2bril mycode.ts\nThe compiler supports both integers (from core Bril) and floating point numbers. Perhaps somewhat surprisingly, plain JavaScript numbers and the TypeScript number type map to float in Bril. For integers, use JavaScript big integers whenever you need an integer, like this:\nvar x: bigint = 5n;\nprintInt(x);\n\nfunction printInt(x: bigint) {\n    console.log(x);\n}\nThe n suffix on literals distinguishes integer literals, and the bigint type in TypeScript reflects them."
  },
  {
    "objectID": "src/briltxt/docs/tools/ts2bril.html#install",
    "href": "src/briltxt/docs/tools/ts2bril.html#install",
    "title": "TypeScript-to-Bril Compiler",
    "section": "",
    "text": "The TypeScript compiler uses Deno. Type this:\n$ deno install --allow-env --allow-read ts2bril.ts\nIf you haven’t already, you will then need to add $HOME/.deno/bin to [your $PATH][path].\nUse\n\nCompile a TypeScript program to Bril by giving a filename on the command line:\n$ ts2bril mycode.ts\nThe compiler supports both integers (from core Bril) and floating point numbers. Perhaps somewhat surprisingly, plain JavaScript numbers and the TypeScript number type map to float in Bril. For integers, use JavaScript big integers whenever you need an integer, like this:\nvar x: bigint = 5n;\nprintInt(x);\n\nfunction printInt(x: bigint) {\n    console.log(x);\n}\nThe n suffix on literals distinguishes integer literals, and the bigint type in TypeScript reflects them."
  },
  {
    "objectID": "src/briltxt/docs/tools/ocaml.html",
    "href": "src/briltxt/docs/tools/ocaml.html",
    "title": "OCaml Library",
    "section": "",
    "text": "The OCaml bril library, which lives in the bril-ocaml directory, provides an OCaml interface and parser for Bril’s JSON files.\n\n\nTo build the library, you first need to install OCaml. Then, install the dependencies with opam install core yojson.\nTo install the bril-ocaml library:\ngit clone https://github.com/sampsyo/bril path/to/my/bril\nopam pin add -k path bril path/to/brill/bril-ocaml\nopam install bril\nThat’s it! You can include it in your Dune files as bril, like any other OCaml library.\nUse\n\nThe interface for the library can be found in bril.mli—good starting points are from_string, from_file, and to_string. A small code example for the library lives in the count subdirectory.\nIf you wish to make changes to the bril OCaml library, simply hack on the git clone.\nWhen you are done, simply reinstall the package with opam reinstall bril. Restart the build of your local project to pick up changes made to bril-ocaml.\n\n\n\nocamlformat is recommended for style consistency. The dune documentation on Automatic Formatting has information about using ocamlformat with dune."
  },
  {
    "objectID": "src/briltxt/docs/tools/ocaml.html#install",
    "href": "src/briltxt/docs/tools/ocaml.html#install",
    "title": "OCaml Library",
    "section": "",
    "text": "To build the library, you first need to install OCaml. Then, install the dependencies with opam install core yojson.\nTo install the bril-ocaml library:\ngit clone https://github.com/sampsyo/bril path/to/my/bril\nopam pin add -k path bril path/to/brill/bril-ocaml\nopam install bril\nThat’s it! You can include it in your Dune files as bril, like any other OCaml library.\nUse\n\nThe interface for the library can be found in bril.mli—good starting points are from_string, from_file, and to_string. A small code example for the library lives in the count subdirectory.\nIf you wish to make changes to the bril OCaml library, simply hack on the git clone.\nWhen you are done, simply reinstall the package with opam reinstall bril. Restart the build of your local project to pick up changes made to bril-ocaml."
  },
  {
    "objectID": "src/briltxt/docs/tools/ocaml.html#for-development",
    "href": "src/briltxt/docs/tools/ocaml.html#for-development",
    "title": "OCaml Library",
    "section": "",
    "text": "ocamlformat is recommended for style consistency. The dune documentation on Automatic Formatting has information about using ocamlformat with dune."
  },
  {
    "objectID": "src/briltxt/docs/tools/brench.html",
    "href": "src/briltxt/docs/tools/brench.html",
    "title": "Brench",
    "section": "",
    "text": "Brench is a simple benchmark runner to help you measure the impact of optimizations. It can run the same set of benchmarks under multiple treatments, check that they still produce the correct answer, and report their performance under every condition.\n\n\nBrench is a Python tool. There is a brench/ subdirectory in the Bril repository. Get Flit and then type:\n$ flit install --symlink --user\n\n\n\nWrite a configuration file using TOML. Start with something like this:\nextract = 'total_dyn_inst: (\\d+)'\nbenchmarks = '../benchmarks/*.bril'\n\n[runs.baseline]\npipeline = [\n    \"bril2json\",\n    \"brili -p {args}\",\n]\n\n[runs.myopt]\npipeline = [\n    \"bril2json\",\n    \"myopt\",\n    \"brili -p {args}\",\n]\nThe global options are:\n\nextract: A regular expression to extract the figure of merit from a given run of a given benchmark. The example above gets the simple profiling output from the Bril interpreter in -p mode.\nbenchmarks (optional): A shell glob matching the benchmark files to run. You can also specify the files on the command line (see below).\ntimeout (optional): The timeout of each benchmark run in seconds. Default of 5 seconds.\n\nThen, define an map of runs, which are the different treatments you want to give to each benchmark. Each one needs a pipeline, which is a list of shell commands to run in a pipelined fashion on the benchmark file, which Brench will send to the first command’s standard input. The first run constitutes the “golden” output; subsequent runs will need to match this output.\nRun\n\nJust give Brench your config file and it will give you results as a CSV:\n$ brench example.toml &gt; results.csv\nYou can also specify a list of files after the configuration file to run a specified list of benchmarks, ignoring the pre-configured glob in the configuration file.\nThe command has only one command-line option:\n\n--jobs or -j: The number of parallel jobs to run. Set to 1 to run everything sequentially. By default, Brench tries to guess an adequate number of threads to fill up your machine.\n\nThe output CSV has three columns: benchmark, run, and result. The latter is the value extracted from the run’s standard output and standard error using the extract regular expression or one of these three status indicators:\n\nincorrect: The output did not match the “golden” output (from the first run).\ntimeout: Execution took too long.\nmissing: The extract regex did not match in the final pipeline stage’s standard output or standard error.\n\nTo check that a run’s output is “correct,” Brench compares its standard output to that of the first run (baseline in the above example, but it’s whichever run configuration comes first). The comparison is an exact string match."
  },
  {
    "objectID": "src/briltxt/docs/tools/brench.html#set-up",
    "href": "src/briltxt/docs/tools/brench.html#set-up",
    "title": "Brench",
    "section": "",
    "text": "Brench is a Python tool. There is a brench/ subdirectory in the Bril repository. Get Flit and then type:\n$ flit install --symlink --user"
  },
  {
    "objectID": "src/briltxt/docs/tools/brench.html#configure",
    "href": "src/briltxt/docs/tools/brench.html#configure",
    "title": "Brench",
    "section": "",
    "text": "Write a configuration file using TOML. Start with something like this:\nextract = 'total_dyn_inst: (\\d+)'\nbenchmarks = '../benchmarks/*.bril'\n\n[runs.baseline]\npipeline = [\n    \"bril2json\",\n    \"brili -p {args}\",\n]\n\n[runs.myopt]\npipeline = [\n    \"bril2json\",\n    \"myopt\",\n    \"brili -p {args}\",\n]\nThe global options are:\n\nextract: A regular expression to extract the figure of merit from a given run of a given benchmark. The example above gets the simple profiling output from the Bril interpreter in -p mode.\nbenchmarks (optional): A shell glob matching the benchmark files to run. You can also specify the files on the command line (see below).\ntimeout (optional): The timeout of each benchmark run in seconds. Default of 5 seconds.\n\nThen, define an map of runs, which are the different treatments you want to give to each benchmark. Each one needs a pipeline, which is a list of shell commands to run in a pipelined fashion on the benchmark file, which Brench will send to the first command’s standard input. The first run constitutes the “golden” output; subsequent runs will need to match this output.\nRun\n\nJust give Brench your config file and it will give you results as a CSV:\n$ brench example.toml &gt; results.csv\nYou can also specify a list of files after the configuration file to run a specified list of benchmarks, ignoring the pre-configured glob in the configuration file.\nThe command has only one command-line option:\n\n--jobs or -j: The number of parallel jobs to run. Set to 1 to run everything sequentially. By default, Brench tries to guess an adequate number of threads to fill up your machine.\n\nThe output CSV has three columns: benchmark, run, and result. The latter is the value extracted from the run’s standard output and standard error using the extract regular expression or one of these three status indicators:\n\nincorrect: The output did not match the “golden” output (from the first run).\ntimeout: Execution took too long.\nmissing: The extract regex did not match in the final pipeline stage’s standard output or standard error.\n\nTo check that a run’s output is “correct,” Brench compares its standard output to that of the first run (baseline in the above example, but it’s whichever run configuration comes first). The comparison is an exact string match."
  },
  {
    "objectID": "src/briltxt/docs/tools/brilck.html",
    "href": "src/briltxt/docs/tools/brilck.html",
    "title": "Type Checker",
    "section": "",
    "text": "Bril comes with a simple type checker to catch errors statically. It checks the types of instructions in the core language and the floating point, SSA, memory, and speculation extensions. It also checks calls and return values and the labels used in control flow.\n\n\nThe brilck tool uses Deno. Type this:\n$ deno install brilck.ts\nIf you haven’t already, you will then need to add $HOME/.deno/bin to [your $PATH][path].\n\n\n\nJust pipe a Bril program into brilck:\nbril2json &lt; benchmarks/fizz-buzz.bril | brilck\nIt will print any problems it finds to standard error. (If it doesn’t find any problems, it doesn’t print anything at all.)\nYou can optionally provide a filename as a (sole) command-line argument. This filename will appear in any error messages for easier parsing when many files are involved.\nConsider supplying the -p flag to the bril2json parser to get source positions in the error messages."
  },
  {
    "objectID": "src/briltxt/docs/tools/brilck.html#install",
    "href": "src/briltxt/docs/tools/brilck.html#install",
    "title": "Type Checker",
    "section": "",
    "text": "The brilck tool uses Deno. Type this:\n$ deno install brilck.ts\nIf you haven’t already, you will then need to add $HOME/.deno/bin to [your $PATH][path]."
  },
  {
    "objectID": "src/briltxt/docs/tools/brilck.html#check",
    "href": "src/briltxt/docs/tools/brilck.html#check",
    "title": "Type Checker",
    "section": "",
    "text": "Just pipe a Bril program into brilck:\nbril2json &lt; benchmarks/fizz-buzz.bril | brilck\nIt will print any problems it finds to standard error. (If it doesn’t find any problems, it doesn’t print anything at all.)\nYou can optionally provide a filename as a (sole) command-line argument. This filename will appear in any error messages for easier parsing when many files are involved.\nConsider supplying the -p flag to the bril2json parser to get source positions in the error messages."
  },
  {
    "objectID": "src/briltxt/docs/tools/infer.html",
    "href": "src/briltxt/docs/tools/infer.html",
    "title": "Type Inference",
    "section": "",
    "text": "Type Inference\nBril requires exhaustive type annotations on every instruction, which can quickly get tedious. The type-infer directory contains a simple global type inference tool that fills in missing type annotations. For example, it can turn this easier-to-write program:\n@main(arg: int) {\n  five = const 5;\n  ten = const 10;\n  res = add arg five;\n  cond = le res ten;\n  br cond .then .else;\n.then:\n  print res;\n.else:\n}\nInto this actually executable program:\n@main(arg: int) {\n  five: int = const 5;\n  ten: int = const 10;\n  res: int = add arg five;\n  cond: bool = le res ten;\n  br cond .then .else;\n.then:\n  print res;\n.else:\n}\nThe tool is a simple Python program, infer.py, that takes JSON programs that are missing types and adds types to them. It is also useful even on fully-typed programs as a type checker to rule out common run-time errors. The included text format tools support missing types for both parsing and printing, so here’s a shell pipeline that adds types to your text-format Bril program:\ncat myprog.bril | bril2json | python type-infer/infer.py | bril2txt\nYou can read more about the inference tool, which is originally by Christopher Roman.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "src/briltxt/docs/tools/web-playground.html",
    "href": "src/briltxt/docs/tools/web-playground.html",
    "title": "Web Playground",
    "section": "",
    "text": "Web playground is available for Bril.\nFeatures: - Code evaluation using the reference interpreter - CFG visualization - Dominator visualization - SSA transformation\n\n\nhttps://github.com/agentcooper/bril-playground"
  },
  {
    "objectID": "src/briltxt/docs/tools/web-playground.html#source-code",
    "href": "src/briltxt/docs/tools/web-playground.html#source-code",
    "title": "Web Playground",
    "section": "",
    "text": "https://github.com/agentcooper/bril-playground"
  },
  {
    "objectID": "src/briltxt/docs/intro.html",
    "href": "src/briltxt/docs/intro.html",
    "title": "Bril: A Compiler Intermediate Representation for Learning",
    "section": "",
    "text": "Bril: A Compiler Intermediate Representation for Learning\nBril, the Big Red Intermediate Language, is a programming language for learning about compilers. It’s the intermediate representation we use in CS 6120, a PhD-level compilers course. Bril’s design tenets include:\n\nBril is an instruction-oriented language, like most good IRs.\nThe core is minimal and ruthlessly regular. Extensions make it interesting.\nThe tooling is language agnostic. Bril programs are just JSON.\nBril is typed.\n\nSee the language reference for the complete language specification and the tool documentation for details on the “batteries included” monorepo.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "src/briltxt/docs/lang/core.html",
    "href": "src/briltxt/docs/lang/core.html",
    "title": "Core Language",
    "section": "",
    "text": "This section describes the core Bril instructions. Any self-respecting Bril tool must support all of these operations; other extensions are more optional.\n\n\nCore Bril defines two primitive types:\n\nint: 64-bit, two’s complement, signed integers.\nbool: True or false.\n\n\n\n\nThese instructions are the obvious binary integer arithmetic operations. They all take two arguments, which must be names of variables of type int, and produce a result of type int:\n\nadd: x + y.\nmul: x × y.\nsub: x - y.\ndiv: x ÷ y.\n\nIn each case, overflow follows two’s complement rules. It is an error to div by zero.\n\n\n\nThese instructions compare integers. They all take two arguments of type int and produce a result of type bool:\n\neq: Equal.\nlt: Less than.\ngt: Greater than.\nle: Less than or equal to.\nge: Greater than or equal to.\n\n\n\n\nThese are the basic Boolean logic operators. They take arguments of type bool and produce a result of type bool:\n\nnot (1 argument)\nand (2 arguments)\nor (2 arguments)\n\n\n\n\nThese are the control flow operations. Unlike the value operations above, they take labels and functions in addition to normal arguments.\n\njmp: Unconditional jump. One label: the label to jump to.\nbr: Conditional branch. One argument: a variable of type bool. Two labels: a true label and a false label. Transfer control to one of the two labels depending on the value of the variable.\ncall: Function invocation. Takes the name of the function to call and, as its arguments, the function parameters. The call instruction can be a Value Operation or an Effect Operation, depending on whether the function returns a value.\nret: Function return. Stop executing the current activation record and return to the parent (or exit the program if this is the top-level main activation record). It has one optional argument: the return value for the function.\n\nOnly call may (optionally) produce a result; the rest appear only as Effect Operations.\n\n\n\n\nid: A type-insensitive identity. Takes one argument, which is a variable of any type, and produces the same value (which must have the same type, obvi).\nprint: Output values to the console (with a newline). Takes any number of arguments of any type and does not produce a result.\nnop: Do nothing. Takes no arguments and produces no result."
  },
  {
    "objectID": "src/briltxt/docs/lang/core.html#types",
    "href": "src/briltxt/docs/lang/core.html#types",
    "title": "Core Language",
    "section": "",
    "text": "Core Bril defines two primitive types:\n\nint: 64-bit, two’s complement, signed integers.\nbool: True or false."
  },
  {
    "objectID": "src/briltxt/docs/lang/core.html#arithmetic",
    "href": "src/briltxt/docs/lang/core.html#arithmetic",
    "title": "Core Language",
    "section": "",
    "text": "These instructions are the obvious binary integer arithmetic operations. They all take two arguments, which must be names of variables of type int, and produce a result of type int:\n\nadd: x + y.\nmul: x × y.\nsub: x - y.\ndiv: x ÷ y.\n\nIn each case, overflow follows two’s complement rules. It is an error to div by zero."
  },
  {
    "objectID": "src/briltxt/docs/lang/core.html#comparison",
    "href": "src/briltxt/docs/lang/core.html#comparison",
    "title": "Core Language",
    "section": "",
    "text": "These instructions compare integers. They all take two arguments of type int and produce a result of type bool:\n\neq: Equal.\nlt: Less than.\ngt: Greater than.\nle: Less than or equal to.\nge: Greater than or equal to."
  },
  {
    "objectID": "src/briltxt/docs/lang/core.html#logic",
    "href": "src/briltxt/docs/lang/core.html#logic",
    "title": "Core Language",
    "section": "",
    "text": "These are the basic Boolean logic operators. They take arguments of type bool and produce a result of type bool:\n\nnot (1 argument)\nand (2 arguments)\nor (2 arguments)"
  },
  {
    "objectID": "src/briltxt/docs/lang/core.html#control",
    "href": "src/briltxt/docs/lang/core.html#control",
    "title": "Core Language",
    "section": "",
    "text": "These are the control flow operations. Unlike the value operations above, they take labels and functions in addition to normal arguments.\n\njmp: Unconditional jump. One label: the label to jump to.\nbr: Conditional branch. One argument: a variable of type bool. Two labels: a true label and a false label. Transfer control to one of the two labels depending on the value of the variable.\ncall: Function invocation. Takes the name of the function to call and, as its arguments, the function parameters. The call instruction can be a Value Operation or an Effect Operation, depending on whether the function returns a value.\nret: Function return. Stop executing the current activation record and return to the parent (or exit the program if this is the top-level main activation record). It has one optional argument: the return value for the function.\n\nOnly call may (optionally) produce a result; the rest appear only as Effect Operations."
  },
  {
    "objectID": "src/briltxt/docs/lang/core.html#miscellaneous",
    "href": "src/briltxt/docs/lang/core.html#miscellaneous",
    "title": "Core Language",
    "section": "",
    "text": "id: A type-insensitive identity. Takes one argument, which is a variable of any type, and produces the same value (which must have the same type, obvi).\nprint: Output values to the console (with a newline). Takes any number of arguments of any type and does not produce a result.\nnop: Do nothing. Takes no arguments and produces no result."
  },
  {
    "objectID": "src/briltxt/docs/lang/syntax.html",
    "href": "src/briltxt/docs/lang/syntax.html",
    "title": "Syntax Reference",
    "section": "",
    "text": "Bril programs are JSON objects that directly represent abstract syntax. This chapter exhaustively describes the structure of that syntax. All objects are JSON values of one sort or another.\n\n\n{ \"functions\": [&lt;Function&gt;, ...] }\nA Program is the top-level object. It has one key:\n\nfunctions, a list of Function objects.\n\n\n\n\n\"&lt;string&gt;\"\n{\"&lt;string&gt;\": &lt;Type&gt;}\nThere are two kinds of types: primitive types, whose syntax is just a string, and parameterized types, which wrap a smaller type. The semantics chapters list the particular types that are available—for example, core Bril defines the basic primitive types int and bool and the memory extension defines a parameterized pointer type.\n\n\n\n{\n  \"name\": \"&lt;string&gt;\",\n  \"args\": [{\"name\": \"&lt;string&gt;\", \"type\": &lt;Type&gt;}, ...]?,\n  \"type\": &lt;Type&gt;?,\n  \"instrs\": [&lt;Instruction&gt;, ...]\n}\nA Function object represents a (first-order) procedure consisting of a sequence of instructions. There are four fields:\n\nname, a string.\nargs, optionally, a list of arguments, which consist of a name and a type. Missing args is the same as an empty list.\nOptionally, type, a Type object: the function’s return type, if any.\ninstrs, a list of Label and Instruction objects.\n\nWhen a function runs, it creates an activation record and transfers control to the first instruction in the sequence.\nA Bril program is executable if it contains a function named main. When execution starts, this function will be invoked. The main function can have arguments (which implementations may supply using command-line arguments) but must not have a return type.\n\n\n\n{ \"label\": \"&lt;string&gt;\" }\nA Label marks a position in an instruction sequence as a destination for control transfers. It only has one key:\n\nlabel, a string. This is the name that jump and branch instructions will use to transfer control to this position and proceed to execute the following instruction.\n\n\n\n\n{ \"op\": \"&lt;string&gt;\", ... }\nAn Instruction represents a unit of computational work. Every instruction must have this field:\n\nop, a string: the opcode that determines what the instruction does. (See the Core Language section and the subsequent extension sections for listings of the available opcodes.)\n\nDepending on the opcode, the instruction might also have:\n\ndest, a string: the name of the variable where the operation’s result is stored.\ntype, a Type object: the type of the destination variable.\nargs, a list of strings: the arguments to the operation. These are names of variables.\nfuncs, a list of strings: any names of functions referenced by the instruction.\nlabels, a list of strings: any label names referenced by the instruction.\n\nThere are three kinds of instructions: constants, value operations, and effect operations.\n\n\n{ \"op\": \"const\", \"dest\": \"&lt;string&gt;\", \"type\": &lt;Type&gt;,\n  \"value\": &lt;literal&gt; }\nA Constant is an instruction that produces a literal value. Its op field must be the string \"const\". It has the dest and type fields described above, and also:\n\nvalue, the literal value for the constant. This is either a JSON number or a JSON Boolean value. The type field must match—i.e., it must be “int” or “bool”, respectively.\n\n\n\n\n{ \"op\": \"&lt;string&gt;\", \"dest\": \"&lt;string&gt;\", \"type\": &lt;Type&gt;,\n  \"args\": [\"&lt;string&gt;\", ...]?,\n  \"funcs\": [\"&lt;string&gt;\", ...]?,\n  \"labels\": [\"&lt;string&gt;\", ...]? }\nA Value Operation is an instruction that takes arguments, does some computation, and produces a value. Like a Constant, it has the dest and type fields described above, and also any of these three optional fields:\n\nargs, a list of strings. These are variable names defined elsewhere in the same function.\nfuncs, a list of strings. The names of any functions that this instruction references. For example, core Bril’s call instruction takes one function name.\nlabels, a list of strings. The names of any labels within the current function that the instruction references. For example, core Bril’s jump and branch instructions have target labels.\n\nIn all three cases, these keys may be missing and the semantics are identical to mapping to an empty list.\n\n\n\n{ \"op\": \"&lt;string&gt;\",\n  \"args\": [\"&lt;string&gt;\", ...]?,\n  \"funcs\": [\"&lt;string&gt;\", ...]?,\n  \"labels\": [\"&lt;string&gt;\", ...]? }\nAn Effect Operation is like a Value Operation but it does not produce a value. It also has the optional args, funcs, and labels fields.\n\n\n\n\nAny syntax object may optionally have position fields to reflect a source position:\n{ ..., \"pos\": {\"row\": &lt;int&gt;, \"col\": &lt;int&gt;},\n       \"pos_end\": {\"row\": &lt;int&gt;, \"col\": &lt;int&gt;}?,\n       \"src\": \"&lt;string&gt;\"? }\nThe pos and pos_end objects have two keys: row (the line number) and col (the column number within the line). The src object can optionally provide the absolute path to a file which is referenced to by the source position. If pos_end is provided, it must be equal to or greater than pos. Front-end compilers that generate Bril code may add this information to help with debugging. The text format parser, for example, can optionally add source positions. However, tools can’t require positions to exist, to consistently exist or not on all syntax objects in a program, or to follow any particular rules."
  },
  {
    "objectID": "src/briltxt/docs/lang/syntax.html#program",
    "href": "src/briltxt/docs/lang/syntax.html#program",
    "title": "Syntax Reference",
    "section": "",
    "text": "{ \"functions\": [&lt;Function&gt;, ...] }\nA Program is the top-level object. It has one key:\n\nfunctions, a list of Function objects."
  },
  {
    "objectID": "src/briltxt/docs/lang/syntax.html#type",
    "href": "src/briltxt/docs/lang/syntax.html#type",
    "title": "Syntax Reference",
    "section": "",
    "text": "\"&lt;string&gt;\"\n{\"&lt;string&gt;\": &lt;Type&gt;}\nThere are two kinds of types: primitive types, whose syntax is just a string, and parameterized types, which wrap a smaller type. The semantics chapters list the particular types that are available—for example, core Bril defines the basic primitive types int and bool and the memory extension defines a parameterized pointer type."
  },
  {
    "objectID": "src/briltxt/docs/lang/syntax.html#function",
    "href": "src/briltxt/docs/lang/syntax.html#function",
    "title": "Syntax Reference",
    "section": "",
    "text": "{\n  \"name\": \"&lt;string&gt;\",\n  \"args\": [{\"name\": \"&lt;string&gt;\", \"type\": &lt;Type&gt;}, ...]?,\n  \"type\": &lt;Type&gt;?,\n  \"instrs\": [&lt;Instruction&gt;, ...]\n}\nA Function object represents a (first-order) procedure consisting of a sequence of instructions. There are four fields:\n\nname, a string.\nargs, optionally, a list of arguments, which consist of a name and a type. Missing args is the same as an empty list.\nOptionally, type, a Type object: the function’s return type, if any.\ninstrs, a list of Label and Instruction objects.\n\nWhen a function runs, it creates an activation record and transfers control to the first instruction in the sequence.\nA Bril program is executable if it contains a function named main. When execution starts, this function will be invoked. The main function can have arguments (which implementations may supply using command-line arguments) but must not have a return type."
  },
  {
    "objectID": "src/briltxt/docs/lang/syntax.html#label",
    "href": "src/briltxt/docs/lang/syntax.html#label",
    "title": "Syntax Reference",
    "section": "",
    "text": "{ \"label\": \"&lt;string&gt;\" }\nA Label marks a position in an instruction sequence as a destination for control transfers. It only has one key:\n\nlabel, a string. This is the name that jump and branch instructions will use to transfer control to this position and proceed to execute the following instruction."
  },
  {
    "objectID": "src/briltxt/docs/lang/syntax.html#instruction",
    "href": "src/briltxt/docs/lang/syntax.html#instruction",
    "title": "Syntax Reference",
    "section": "",
    "text": "{ \"op\": \"&lt;string&gt;\", ... }\nAn Instruction represents a unit of computational work. Every instruction must have this field:\n\nop, a string: the opcode that determines what the instruction does. (See the Core Language section and the subsequent extension sections for listings of the available opcodes.)\n\nDepending on the opcode, the instruction might also have:\n\ndest, a string: the name of the variable where the operation’s result is stored.\ntype, a Type object: the type of the destination variable.\nargs, a list of strings: the arguments to the operation. These are names of variables.\nfuncs, a list of strings: any names of functions referenced by the instruction.\nlabels, a list of strings: any label names referenced by the instruction.\n\nThere are three kinds of instructions: constants, value operations, and effect operations.\n\n\n{ \"op\": \"const\", \"dest\": \"&lt;string&gt;\", \"type\": &lt;Type&gt;,\n  \"value\": &lt;literal&gt; }\nA Constant is an instruction that produces a literal value. Its op field must be the string \"const\". It has the dest and type fields described above, and also:\n\nvalue, the literal value for the constant. This is either a JSON number or a JSON Boolean value. The type field must match—i.e., it must be “int” or “bool”, respectively.\n\n\n\n\n{ \"op\": \"&lt;string&gt;\", \"dest\": \"&lt;string&gt;\", \"type\": &lt;Type&gt;,\n  \"args\": [\"&lt;string&gt;\", ...]?,\n  \"funcs\": [\"&lt;string&gt;\", ...]?,\n  \"labels\": [\"&lt;string&gt;\", ...]? }\nA Value Operation is an instruction that takes arguments, does some computation, and produces a value. Like a Constant, it has the dest and type fields described above, and also any of these three optional fields:\n\nargs, a list of strings. These are variable names defined elsewhere in the same function.\nfuncs, a list of strings. The names of any functions that this instruction references. For example, core Bril’s call instruction takes one function name.\nlabels, a list of strings. The names of any labels within the current function that the instruction references. For example, core Bril’s jump and branch instructions have target labels.\n\nIn all three cases, these keys may be missing and the semantics are identical to mapping to an empty list.\n\n\n\n{ \"op\": \"&lt;string&gt;\",\n  \"args\": [\"&lt;string&gt;\", ...]?,\n  \"funcs\": [\"&lt;string&gt;\", ...]?,\n  \"labels\": [\"&lt;string&gt;\", ...]? }\nAn Effect Operation is like a Value Operation but it does not produce a value. It also has the optional args, funcs, and labels fields."
  },
  {
    "objectID": "src/briltxt/docs/lang/syntax.html#source-positions",
    "href": "src/briltxt/docs/lang/syntax.html#source-positions",
    "title": "Syntax Reference",
    "section": "",
    "text": "Any syntax object may optionally have position fields to reflect a source position:\n{ ..., \"pos\": {\"row\": &lt;int&gt;, \"col\": &lt;int&gt;},\n       \"pos_end\": {\"row\": &lt;int&gt;, \"col\": &lt;int&gt;}?,\n       \"src\": \"&lt;string&gt;\"? }\nThe pos and pos_end objects have two keys: row (the line number) and col (the column number within the line). The src object can optionally provide the absolute path to a file which is referenced to by the source position. If pos_end is provided, it must be equal to or greater than pos. Front-end compilers that generate Bril code may add this information to help with debugging. The text format parser, for example, can optionally add source positions. However, tools can’t require positions to exist, to consistently exist or not on all syntax objects in a program, or to follow any particular rules."
  },
  {
    "objectID": "src/briltxt/docs/lang/char.html",
    "href": "src/briltxt/docs/lang/char.html",
    "title": "Character",
    "section": "",
    "text": "The character extension adds one new base type:\n\"char\"\nCharacters are a singular Unicode character.\n\n\n\nComparison operators, which take two char values and produce a bool:\n\nceq\nclt\ncle\ncgt\ncge\n\nConversion operators:\n\nchar2int: One argument: a variable of type char. Returns an integer representing the Unicode code point of the given value.\nint2char: One argument: a variable of type int. Returns the corresponding Unicode character. Throws if the value does not correspond to a valid Unicode code point.\n\n\n\n\nThe core print operation prints char values."
  },
  {
    "objectID": "src/briltxt/docs/lang/char.html#types",
    "href": "src/briltxt/docs/lang/char.html#types",
    "title": "Character",
    "section": "",
    "text": "The character extension adds one new base type:\n\"char\"\nCharacters are a singular Unicode character."
  },
  {
    "objectID": "src/briltxt/docs/lang/char.html#operations",
    "href": "src/briltxt/docs/lang/char.html#operations",
    "title": "Character",
    "section": "",
    "text": "Comparison operators, which take two char values and produce a bool:\n\nceq\nclt\ncle\ncgt\ncge\n\nConversion operators:\n\nchar2int: One argument: a variable of type char. Returns an integer representing the Unicode code point of the given value.\nint2char: One argument: a variable of type int. Returns the corresponding Unicode character. Throws if the value does not correspond to a valid Unicode code point."
  },
  {
    "objectID": "src/briltxt/docs/lang/char.html#printing",
    "href": "src/briltxt/docs/lang/char.html#printing",
    "title": "Character",
    "section": "",
    "text": "The core print operation prints char values."
  },
  {
    "objectID": "src/briltxt/docs/lang/float.html",
    "href": "src/briltxt/docs/lang/float.html",
    "title": "Floating Point",
    "section": "",
    "text": "Bril has an extension for computing on floating-point numbers.\nYou can read more about the extension, which is originally by Dietrich Geisler and originally included two FP precision levels.\n\n\nThe floating point extension adds one new base type:\n\"float\"\nFloating point numbers are 64-bit, double-precision IEEE 754 values. (There is no single-precision type.)\n\n\n\nThere are the standard arithmetic operations, which take two float values and produce a new float value:\n\nfadd\nfmul\nfsub\nfdiv\n\nIt is not an error to fdiv by zero; as in IEEE 754, the result is infinity.\nThere are also comparison operators, which take two float values and produce a bool:\n\nfeq\nflt\nfle\nfgt\nfge\n\n\n\n\nThe core print operation prints float values with 17 decimal digits of precision, including trailing zeros. (This is like using the %.17lf format specifier in C’s printf.) Positive and negative zero, while they are equal according to feq, look different when printed. Not-a-number values are printed as NaN; infinite values are printed as the strings Infinity or -Infinity."
  },
  {
    "objectID": "src/briltxt/docs/lang/float.html#types",
    "href": "src/briltxt/docs/lang/float.html#types",
    "title": "Floating Point",
    "section": "",
    "text": "The floating point extension adds one new base type:\n\"float\"\nFloating point numbers are 64-bit, double-precision IEEE 754 values. (There is no single-precision type.)"
  },
  {
    "objectID": "src/briltxt/docs/lang/float.html#operations",
    "href": "src/briltxt/docs/lang/float.html#operations",
    "title": "Floating Point",
    "section": "",
    "text": "There are the standard arithmetic operations, which take two float values and produce a new float value:\n\nfadd\nfmul\nfsub\nfdiv\n\nIt is not an error to fdiv by zero; as in IEEE 754, the result is infinity.\nThere are also comparison operators, which take two float values and produce a bool:\n\nfeq\nflt\nfle\nfgt\nfge"
  },
  {
    "objectID": "src/briltxt/docs/lang/float.html#printing",
    "href": "src/briltxt/docs/lang/float.html#printing",
    "title": "Floating Point",
    "section": "",
    "text": "The core print operation prints float values with 17 decimal digits of precision, including trailing zeros. (This is like using the %.17lf format specifier in C’s printf.) Positive and negative zero, while they are equal according to feq, look different when printed. Not-a-number values are printed as NaN; infinite values are printed as the strings Infinity or -Infinity."
  },
  {
    "objectID": "lectures/03b_local_value_numbering.html",
    "href": "lectures/03b_local_value_numbering.html",
    "title": "3b local value numbering",
    "section": "",
    "text": "Local Value Numbering\nValue numbering is a very powerfull technique that removes redunancies, An instruction x + y is redundant inside a block if it has already been computed in the block, and no intervening operation redefines x or y. If the compiler finds a redundant expression, it can save that value at the first computation and replace any subsequent evaluations with references to the saved value.\nThe idea is simple - The algorithm executes the block, Each time it sees a new variable it gives it a value (reprented as a number) Each time it sees an instruction it forms a hash of the op code and t he value numbers of its operands and gives tha a new value number.\nTwo instructions are redundent if they have same op code and operands, which means the same value number\ne_i and e_j have the same value number if and only if e_i and e_j are provably equal for all possible operands of the expressions.\nlocal value numbering covers lot of optimizations\ndead code elimination\n\nmain {\n    a: int = const 100;\n    a: int = const 42;\n    print a;\n\n}\n\ncopy propagation\n\nmain{\n    x: int = const 4;\n    copy1: int = id x;\n    copy2: int = id copy1;\n    print copy2;\n}\n\ncommon subexpression elimination cse \n\nmain {\n    a: int = const 4;\n    b: int = const 2;\n    sum1: int = add a b;\n    sum2: int = add a b;\n    prod: int = mul sum1 sum2;\n    print prod;\n}\nWe want to stop thinking about varaibles and think about values. Two instructions are redundent if they compute the same value.\n\n\nthis is a very deep idea that comes up multiple times.\nfor example in a JIT compiler we want computation to be fast so we can get rid of all the variables\nb: int const 1;\nc: int cont 2;\na:  int b c;  \nbecomes:\n[  int const 1\n   int const 2 \n   int 0 1\n]\nless storage, args are just pointers, instructions are smaller. faster becuase any use points to the corresponding def without any searching.\nPsuedu code (similar to an interpreter)\nhash table constants and expressions of value numbers to value numbers and a variable holding the value\nreverse map from variable to value numbers\n  main {\n    a: int = const 4;\n    b: int = const 2;\n    sum1: int = add a b;\n    sum2: int = add a b;\n    prod: int = mult sum1 sum2;\n    print prod\n\n  }\ntable\n\n\n\nkey\nvalue\ncanonical name\n\n\n\n\nconst 4\n1\na\n\n\nconst 2\n2\nb\n\n\nadd 1 2\n3\nsum1\n\n\nmul 3 3\n4\nprod\n\n\n\nrevese map\n\n\n\nname\nvalue\n\n\n\n\na\n1\n\n\nb\n2\n\n\nsum1\n3\n\n\nsum2\n3\n\n\nprod\n4\n\n\n\nas we lookup each instruction - replace each arg with the cannonical home\nif the value is already in the table replace with an id from cannonical home\nextensions\n\na: int id b\n\na gets the value number of b. No copy requred\n\n: int add a b; for add sort value numbers so add a b; and add b a; get the same value number\n\n\nconstant folding \n   a: int const 1;\n   b: int const 2;\n   c: add a b;\nif both value numbers are pointing to constants- actually do the add\n\n\npsuedu code\n   table = mapping from value tuples to canonical variables,\n     with each row numbered\n   var2num = mapping from variable names to their current\n     value numbers (i.e., rows in table)\n\n   for instr in block:\n       value = (instr.op, var2num[instr.args[0]], ...)\n\n       if value in table:\n           # The value has been computed before; reuse it.\n           num, var = table[value]\n           replace instr with copy of var\n\n       else:\n           # A newly computed value.\n           num = fresh value number\n\n           dest = instr.dest\n           if instr.dest  will be overwritten later:\n                dest = fresh variable name\n                instr.dest = dest\n           else:\n                dest = instr.dest\n\n           table[value] = num, dest\n\n           for a in instr.args:\n               replace a with table[var2num[a]].var\n\n       var2num[instr.dest] = num\nproblem: cononical variables being overwritten\n``` x = a+b\nx = = a+b\n```\n\nLocal value numbering.\n\nYou can see my implementation in lvn.py in [the examples directory] in the Bril repository. But seriously, don’t be tempted! You want to write your implementation without looking at mine!\nexamples ### Testing Your Optimizations\nAs part of your tasks for this lesson, you will implement your first two optimizations. The two main things you want your optimizations to do are:\n\nNot break programs.\nMake programs faster, most of the time.\n\nAs with every task in this class, part of the work is checking that you have done what you set out to do—in this case, that your optimizations do those two things. Think carefully about how to make a convincing case for each of those criteria.\nOne tempting methodology might be to handwrite a few small test-case Bril programs (or, worse, borrow the woefully inadequate ones sitting around in the Bril git repository), run them through your optimizations, and look at them to check whether they look right. This does not amount to convincing evidence (maybe you can think of a few specific reasons why).\nWhile there are many ways to be convincing, a pretty good way might be to run your optimization on every single available Bril benchmark, systematically check that it still produces the right output for at least one input, and collect aggregate statistics about some metric you’re interested in. This is a nice way to check for unexpected behavior in programs that you didn’t carefully write yourself to test the cases you’re thinking of.\nIf this is the route you choose, you can do it however you like, I have made a simple tool that you can consider using, called [Brench][]. Brench is not very fancy; it does three things:\n\nIt makes it easy to run a long list of inputs through several different commands. (For example, you can run a long list of Bril benchmarks through an “interpret” command and an “optimize-and-then-interpret” command.)\nIt checks that all the commands agree on their output. (So, in our use case, it checks that optimizing the benchmark doesn’t change its output when interpreted.)\nIt can collect a statistic from each command for comparison. (Like the number of dynamic instructions the interpreter executed, which is a pretty good metric for standard optimizations.)\n\nThose three things are probably what you want to do to make a convincing case for an optimization’s correctness and effectiveness, whether or not you use Brench. It’s there if you want it, but feel free to go your own way!\n\n\n\n\n Back to top",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "3b local value numbering"
    ]
  },
  {
    "objectID": "lectures/13_dynamic_compilers.html",
    "href": "lectures/13_dynamic_compilers.html",
    "title": "13_dynamic_compielrs",
    "section": "",
    "text": "Warning\n\n\n\nnot done\n\n\n\n\n\n Back to top",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "13_dynamic_compielrs"
    ]
  },
  {
    "objectID": "lectures/010_compiler_overview.html",
    "href": "lectures/010_compiler_overview.html",
    "title": "6 static single assignment",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "6 static single assignment"
    ]
  },
  {
    "objectID": "lectures/05_global.html",
    "href": "lectures/05_global.html",
    "title": "5 global analysis",
    "section": "",
    "text": "We are going to define assorted graph properties, that can be calculated on cfgs.\nIn data flow we talked about a matrix all_defs x all_uses which is very sparse and very slow to process. One way to speed it up, is use-def chains, for each use build a list of all defs that might reach that use. Or we could have def-use chains for each def calculate the set of all uses that the def might reach. Both of these are good, but we are going use a much better data structure that is both smaller and faster to process. We also want ways to talk about loops in programs, since optimizations that move instructions inside loops to a place outside loops often speed up programs\nWe first define a binary relation on cfg nodes, called dominance. a node d dominates a node i (d dom i) if every possible execution path in the cfg that goes from the entry to i goes through d. \n\nDom is reflexive, so a dom a for all nodes a.\nDom is transitive, a dom b, b dom c ==&gt; a dom c\nDom is anti-symmetric if a dom b, and b dom a then b = a\n\nWe next define immediate dominators a idom b, a != b and there is no c != a and c != b where a dom c and c dom b.\n\nidom is unique\nidom forms a tree called the dominator tree, root is the entry of the cfg\n\nA strict dominator a sdom b if a dom b and a != b\nA control flow graph\n\n\n\n\n\ngraph TD;\nn0 --&gt; n1;\nn1 --&gt; n2;\nn1 --&gt; n3;\nn2 --&gt; n4;\nn3 --&gt; n4;\n\n\n\n\n\n\nThe dominator tree\n\n\n\n\n\ngraph TD;\nn0 --&gt; n1;\nn0 --&gt; n2;n0 --&gt; n3\nn1 --&gt; n4;\n\n\n\n\n\n\ndominators\n\nn0 dominates n0, n1, n2, n3 and n4\nn1 dominates n1, n2, n3 and n4\nn2 dominates n2\nn3 dominates n3\nn4 dominates n4\n\nimmediate dominators\n\nn0 idom n1\nn0 idom n1\nn3 idom n3\nn1 idom n4\n\na simple implementation\n\\[\n\\begin{gathered}\n\\operatorname{Dom}\\left(n_o\\right)=\\left\\{n_o\\right\\} \\\\\n\\operatorname{Dom}(n)=\\{n\\} \\cup\\left(\\bigcap_{p \\in \\operatorname{preds}(n)} \\operatorname{Dom}(p)\\right)\n\\end{gathered}\n\\]\nTo find the dominators of a node, first put the node itself in the dominators set. Then, take all the common (i.e. intersection) dominators of its predecessors and put them in the set.\nWhat order do we want to process the nodes?\ncompute_dominators(CFG cfg) {\n  cfg[0].dominators = {0}\n  for (bb in cfg except 0) {\n    b.dominators = {all nodes in cfg}\n  }\n\n  do {\n    change = false;\n    for (bb in cfg except 0) {\n      temp = {all nodes in cfg}\n      for (pred in bb.predecessors) {\n        temp = intersect(temp, pred.dominators)\n      }\n      temp = union(temp, {bb})\n      if (temp != bb.dominators) {\n        change = true\n        bb.dominators = temp\n      }\n    }\n  } while (change);\n}\nHow do we implement this\nnumber the vertices starting at 0, vertices are 0,1,2, number_of_vertices -1 so we could use a bit-vector for the set, and we should process vertices in reverse post order\nCooper, Harvey, Kennedy Algorithm\nif we have the dominator tree, finding immediate dominators is easy, its the parent of the node Finding dominators is also easy, its all the parents on the path from the entry to the node\nsuppose we have a node in the cfg with two parents, like n4, if we takes paths backward in the dominator tree the first common ancestor is n1, Which is the dominator\nlets look at a more complex example\n\n\n\n\n\ngraph TD;\nn0 --&gt; n5;\nn0 --&gt; n1;\nn5 --&gt; n7;\nn5 --&gt; n6;\nn1 --&gt; n2 ;\nn1 --&gt; n3;\nn7 --&gt; n8;\nn6 --&gt; n4;\nn2 --&gt; n4;\nn4 --&gt; n8 ;\nn3 --&gt; n8;\n\n\n\n\n\n\nlets look at a more complex example\n\n\n\n\n\ngraph TD;\nn0 --&gt; n5;\nn0 --&gt; n1;\nn5 --&gt; n7;\nn5 --&gt; n6;\nn1 --&gt; n2 ;\nn1 --&gt; n3;\nn7 --&gt; n8;\nn6 --&gt; n4;\nn2 --&gt; n4;\nn4 --&gt; n8 ;\nn3 --&gt; n8;\n\n\n\n\n\n\nsubproblem: find lowest common ancestor of two nodes a and b\nfor each node in the dom tree we have the depth, how far from the root, so if a and b have the same parent, that is the dominator, otherwise move the node with the higher depth up one\na fast way to determine which node is lower the nodes in post order, nodes at the top of the cfg have higher numbers\nvoid compute_dominators(CFG cfg) {\n  // Some initialization steps and e.g. get postorder.\n\n  // Map its basic block to its postorder traversal.\n  foreach (p ; postorder) {\n    postorder_map[p] = counter;\n    ++counter;\n  }\n\n  bool change;\n  do {\n    change = false;\n    foreach_reverse (int i; postorder) {\n      BasicBlock *bb = &cfg[i];\n      int new_idom = bb.preds[0];  // Arbitrarily choose the first predecessor\n      foreach (pred ; bb.preds[1..bb.preds.length]) {\n        if (cfg.idoms[pred] != CFG.UNDEFINED_IDOM) {\n          new_idom = intersect(new_idom, pred, cfg.idoms, postorder_map);\n        }\n      }\n      if (cfg.idoms[i] != new_idom) {\n        cfg.idoms[i] = new_idom;\n        change = true;\n      }\n    }\n  } while (change);\n}\n\nint intersect(int b1, int b2, Array!int idoms, Array!int postorder_map) {\n  while (b1 != b2) {\n    if (postorder_map[b1] &lt; postorder_map[b2]) {\n      b1 = idoms[b1];\n    } else {\n      b2 = idoms[b2];\n    }\n  }\n  return b1;\nA node A has a dominance frontier which are set of nodes b where A does not dominate b but A dominates a pred of b. Lets see n5’ dominance frontier\nFinally we have a post dominates b if all paths from b to the exit go through a. for instance n4 post dominates n6.\n## natural loops\n\n\n\n\n\n  graph TD;\n  entry --&gt; loop\n  loop --&gt; if \n  if --&gt; then\n  if --&gt; else\n  then --&gt; endif\n  else --&gt; endif\n  endif --&gt; loop\n  loop --&gt; exit\n\n\n\n\n\n\nconditions for a natural loop:\n\nhas to have a cycle in cfg (strongly connected)\nsingle entry point (called the header ) header\n\nHow about an example of a cycle that has a cycle and no header\n\n\n\n\n\n    graph TD;\n    entry --&gt; if;\n    if --&gt; loop1\n    if --&gt; loop2\n    loop2 --&gt; loop1\nloop1 --&gt; loop2\n\n\n\n\n\n\nThis loop has two entry points.\ndefine a backedge is an edge A-&gt;B, where B dominates A\nother edges are forward edges\nNatural loops:\n\nfor a backedge A-&gt;B, B is the header of the loop\nthe smallest set of vertices L including A and B, such that for all v in L either preds(v) are in L or v == B\n\nLets see what this means for nested loops\n\n\n\n\n\n    graph TD;\n    entry --&gt; H1\n    H1 --&gt; A\n    A --&gt; H2\n    H2 --&gt; B\n    B --&gt; H2\n    B --&gt; H1\n    H1 --&gt; exit\n\n\n\n\n\n\nBackedges B -&gt; H2, and B-&gt; H1\nfor B-&gt; H2, loop is H2, for B-&gt; H1, loop is H1, A, H2, B\n*** reducible control flow *** in a reducible cfg every back edge has a natural loop.\nA reducible CFG is one with edges that can be partitioned into two disjoint sets: forward edges, and back edges, such that:\nForward edges form a directed acyclic graph with all nodes reachable from the entry node.\nFor all back edges (A, B), node B dominates node A.\nStructured programming languages are often designed such that all CFGs they produce are reducible, and common structured programming statements such as IF, FOR, WHILE, BREAK, and CONTINUE produce reducible graphs. To produce irreducible graphs, statements such as GOTO are needed. Irreducible graphs may also be produced by some compiler optimizations.\nloop has two entry p\nWhere did the name come from:\nT1 and T2 transforms\nT1: Let G be a CFG. Suppose n is a node in G with a self-loop, that is, an edge from n to itself.\nTransformation T1 on node n is removal of this self-loop.\nT2: Let n1 and n2 be nodes in G such that n2 has the unique direct ancestor n1, and n2 is not the initial node. Then transformation T2 on node pair (n1,n2) is merging nodes n1 and n2 into one node, named n1/n2, and deleting the unique edge between them\nint  n = (count + 7) / 8;\nswitch (count % 8) {\ncase 0: do { *to = *from++;\ncase 7:      *to = *from++;\ncase 6:      *to = *from++;\ncase 5:      *to = *from++;\ncase 4:      *to = *from++;\ncase 3:      *to = *from++;\ncase 2:      *to = *from++;\ncase 1:      *to = *from++;\n        } while (--n &gt; 0);\n}\nsimplified control flow\n\n\n\n\n\n    graph TD;\n    entry --&gt; switch;\n    switch --&gt; case0-7\n    switch --&gt; case1\n    switch --&gt; case2\n    case0-7 --&gt; case2\n    case2--&gt; case1\n    case1 --&gt; dowhile\n    dowhile --&gt; case0-7\n    dowhile --&gt; exit\n\n\n\n\n\n\n\n\n\n\n\n    graph TD;\n    entry --&gt; switch;\n    switch --&gt; case1\n    switch --&gt; case2\n    case2--&gt; case1\n    case1 --&gt; dowhile\n    dowhile --&gt; switch\n    dowhile --&gt; exit\n\n\n\n\n\n\nthe argument about no goto’s is really an argument about reducible control flow",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "5 global analysis"
    ]
  },
  {
    "objectID": "lectures/05_global.html#all-kinds-of-graph-properties--",
    "href": "lectures/05_global.html#all-kinds-of-graph-properties--",
    "title": "5 global analysis",
    "section": "",
    "text": "We are going to define assorted graph properties, that can be calculated on cfgs.\nIn data flow we talked about a matrix all_defs x all_uses which is very sparse and very slow to process. One way to speed it up, is use-def chains, for each use build a list of all defs that might reach that use. Or we could have def-use chains for each def calculate the set of all uses that the def might reach. Both of these are good, but we are going use a much better data structure that is both smaller and faster to process. We also want ways to talk about loops in programs, since optimizations that move instructions inside loops to a place outside loops often speed up programs\nWe first define a binary relation on cfg nodes, called dominance. a node d dominates a node i (d dom i) if every possible execution path in the cfg that goes from the entry to i goes through d. \n\nDom is reflexive, so a dom a for all nodes a.\nDom is transitive, a dom b, b dom c ==&gt; a dom c\nDom is anti-symmetric if a dom b, and b dom a then b = a\n\nWe next define immediate dominators a idom b, a != b and there is no c != a and c != b where a dom c and c dom b.\n\nidom is unique\nidom forms a tree called the dominator tree, root is the entry of the cfg\n\nA strict dominator a sdom b if a dom b and a != b\nA control flow graph\n\n\n\n\n\ngraph TD;\nn0 --&gt; n1;\nn1 --&gt; n2;\nn1 --&gt; n3;\nn2 --&gt; n4;\nn3 --&gt; n4;\n\n\n\n\n\n\nThe dominator tree\n\n\n\n\n\ngraph TD;\nn0 --&gt; n1;\nn0 --&gt; n2;n0 --&gt; n3\nn1 --&gt; n4;\n\n\n\n\n\n\ndominators\n\nn0 dominates n0, n1, n2, n3 and n4\nn1 dominates n1, n2, n3 and n4\nn2 dominates n2\nn3 dominates n3\nn4 dominates n4\n\nimmediate dominators\n\nn0 idom n1\nn0 idom n1\nn3 idom n3\nn1 idom n4\n\na simple implementation\n\\[\n\\begin{gathered}\n\\operatorname{Dom}\\left(n_o\\right)=\\left\\{n_o\\right\\} \\\\\n\\operatorname{Dom}(n)=\\{n\\} \\cup\\left(\\bigcap_{p \\in \\operatorname{preds}(n)} \\operatorname{Dom}(p)\\right)\n\\end{gathered}\n\\]\nTo find the dominators of a node, first put the node itself in the dominators set. Then, take all the common (i.e. intersection) dominators of its predecessors and put them in the set.\nWhat order do we want to process the nodes?\ncompute_dominators(CFG cfg) {\n  cfg[0].dominators = {0}\n  for (bb in cfg except 0) {\n    b.dominators = {all nodes in cfg}\n  }\n\n  do {\n    change = false;\n    for (bb in cfg except 0) {\n      temp = {all nodes in cfg}\n      for (pred in bb.predecessors) {\n        temp = intersect(temp, pred.dominators)\n      }\n      temp = union(temp, {bb})\n      if (temp != bb.dominators) {\n        change = true\n        bb.dominators = temp\n      }\n    }\n  } while (change);\n}\nHow do we implement this\nnumber the vertices starting at 0, vertices are 0,1,2, number_of_vertices -1 so we could use a bit-vector for the set, and we should process vertices in reverse post order\nCooper, Harvey, Kennedy Algorithm\nif we have the dominator tree, finding immediate dominators is easy, its the parent of the node Finding dominators is also easy, its all the parents on the path from the entry to the node\nsuppose we have a node in the cfg with two parents, like n4, if we takes paths backward in the dominator tree the first common ancestor is n1, Which is the dominator\nlets look at a more complex example\n\n\n\n\n\ngraph TD;\nn0 --&gt; n5;\nn0 --&gt; n1;\nn5 --&gt; n7;\nn5 --&gt; n6;\nn1 --&gt; n2 ;\nn1 --&gt; n3;\nn7 --&gt; n8;\nn6 --&gt; n4;\nn2 --&gt; n4;\nn4 --&gt; n8 ;\nn3 --&gt; n8;\n\n\n\n\n\n\nlets look at a more complex example\n\n\n\n\n\ngraph TD;\nn0 --&gt; n5;\nn0 --&gt; n1;\nn5 --&gt; n7;\nn5 --&gt; n6;\nn1 --&gt; n2 ;\nn1 --&gt; n3;\nn7 --&gt; n8;\nn6 --&gt; n4;\nn2 --&gt; n4;\nn4 --&gt; n8 ;\nn3 --&gt; n8;\n\n\n\n\n\n\nsubproblem: find lowest common ancestor of two nodes a and b\nfor each node in the dom tree we have the depth, how far from the root, so if a and b have the same parent, that is the dominator, otherwise move the node with the higher depth up one\na fast way to determine which node is lower the nodes in post order, nodes at the top of the cfg have higher numbers\nvoid compute_dominators(CFG cfg) {\n  // Some initialization steps and e.g. get postorder.\n\n  // Map its basic block to its postorder traversal.\n  foreach (p ; postorder) {\n    postorder_map[p] = counter;\n    ++counter;\n  }\n\n  bool change;\n  do {\n    change = false;\n    foreach_reverse (int i; postorder) {\n      BasicBlock *bb = &cfg[i];\n      int new_idom = bb.preds[0];  // Arbitrarily choose the first predecessor\n      foreach (pred ; bb.preds[1..bb.preds.length]) {\n        if (cfg.idoms[pred] != CFG.UNDEFINED_IDOM) {\n          new_idom = intersect(new_idom, pred, cfg.idoms, postorder_map);\n        }\n      }\n      if (cfg.idoms[i] != new_idom) {\n        cfg.idoms[i] = new_idom;\n        change = true;\n      }\n    }\n  } while (change);\n}\n\nint intersect(int b1, int b2, Array!int idoms, Array!int postorder_map) {\n  while (b1 != b2) {\n    if (postorder_map[b1] &lt; postorder_map[b2]) {\n      b1 = idoms[b1];\n    } else {\n      b2 = idoms[b2];\n    }\n  }\n  return b1;\nA node A has a dominance frontier which are set of nodes b where A does not dominate b but A dominates a pred of b. Lets see n5’ dominance frontier\nFinally we have a post dominates b if all paths from b to the exit go through a. for instance n4 post dominates n6.\n## natural loops\n\n\n\n\n\n  graph TD;\n  entry --&gt; loop\n  loop --&gt; if \n  if --&gt; then\n  if --&gt; else\n  then --&gt; endif\n  else --&gt; endif\n  endif --&gt; loop\n  loop --&gt; exit\n\n\n\n\n\n\nconditions for a natural loop:\n\nhas to have a cycle in cfg (strongly connected)\nsingle entry point (called the header ) header\n\nHow about an example of a cycle that has a cycle and no header\n\n\n\n\n\n    graph TD;\n    entry --&gt; if;\n    if --&gt; loop1\n    if --&gt; loop2\n    loop2 --&gt; loop1\nloop1 --&gt; loop2\n\n\n\n\n\n\nThis loop has two entry points.\ndefine a backedge is an edge A-&gt;B, where B dominates A\nother edges are forward edges\nNatural loops:\n\nfor a backedge A-&gt;B, B is the header of the loop\nthe smallest set of vertices L including A and B, such that for all v in L either preds(v) are in L or v == B\n\nLets see what this means for nested loops\n\n\n\n\n\n    graph TD;\n    entry --&gt; H1\n    H1 --&gt; A\n    A --&gt; H2\n    H2 --&gt; B\n    B --&gt; H2\n    B --&gt; H1\n    H1 --&gt; exit\n\n\n\n\n\n\nBackedges B -&gt; H2, and B-&gt; H1\nfor B-&gt; H2, loop is H2, for B-&gt; H1, loop is H1, A, H2, B\n*** reducible control flow *** in a reducible cfg every back edge has a natural loop.\nA reducible CFG is one with edges that can be partitioned into two disjoint sets: forward edges, and back edges, such that:\nForward edges form a directed acyclic graph with all nodes reachable from the entry node.\nFor all back edges (A, B), node B dominates node A.\nStructured programming languages are often designed such that all CFGs they produce are reducible, and common structured programming statements such as IF, FOR, WHILE, BREAK, and CONTINUE produce reducible graphs. To produce irreducible graphs, statements such as GOTO are needed. Irreducible graphs may also be produced by some compiler optimizations.\nloop has two entry p\nWhere did the name come from:\nT1 and T2 transforms\nT1: Let G be a CFG. Suppose n is a node in G with a self-loop, that is, an edge from n to itself.\nTransformation T1 on node n is removal of this self-loop.\nT2: Let n1 and n2 be nodes in G such that n2 has the unique direct ancestor n1, and n2 is not the initial node. Then transformation T2 on node pair (n1,n2) is merging nodes n1 and n2 into one node, named n1/n2, and deleting the unique edge between them\nint  n = (count + 7) / 8;\nswitch (count % 8) {\ncase 0: do { *to = *from++;\ncase 7:      *to = *from++;\ncase 6:      *to = *from++;\ncase 5:      *to = *from++;\ncase 4:      *to = *from++;\ncase 3:      *to = *from++;\ncase 2:      *to = *from++;\ncase 1:      *to = *from++;\n        } while (--n &gt; 0);\n}\nsimplified control flow\n\n\n\n\n\n    graph TD;\n    entry --&gt; switch;\n    switch --&gt; case0-7\n    switch --&gt; case1\n    switch --&gt; case2\n    case0-7 --&gt; case2\n    case2--&gt; case1\n    case1 --&gt; dowhile\n    dowhile --&gt; case0-7\n    dowhile --&gt; exit\n\n\n\n\n\n\n\n\n\n\n\n    graph TD;\n    entry --&gt; switch;\n    switch --&gt; case1\n    switch --&gt; case2\n    case2--&gt; case1\n    case1 --&gt; dowhile\n    dowhile --&gt; switch\n    dowhile --&gt; exit\n\n\n\n\n\n\nthe argument about no goto’s is really an argument about reducible control flow",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "5 global analysis"
    ]
  },
  {
    "objectID": "lectures/05b_licm.html",
    "href": "lectures/05b_licm.html",
    "title": "05 loop invariant code motion",
    "section": "",
    "text": "Loop invariant code motion recognizes computations in loop that produce the same value on each iteration and moves them out of the loop.\nA very common case for this is matrix addressing\na[i,j] might expand to to i4stride_a1 + j *4\nfor j \n  a[i,j] = f(a[i.j+1])\na = \nb = \nresult = 0\nfor (){\n    result += a*b\n}\nif we are going to move code we need a kind of landing pad called a pre-header create a new block b. change all the preds of the loop header to point to the preheader, add an edge from b to the loop header\nWe need two steps:\n\nfind loop invariant instructions,\nmove all the loop invariant instructions to the preheader\n\nAn instruction instr in a loop is loop invariant of:\nevery operand is:\n\nconstant or\nall reaching definitions of this operand are outside of the loop\nthere is exactly one def in loop reaching this operand and that def is loop invariant\n\niterate to convergence\n for each instr in  the loop\n  mark it at li iff \n     for all arguments x either\n         all reaching defs of x are outside of the loop (this covers constants)\n         or there is exactly one def of instr in the loop and that def is loop invar\nwhen is ok to move an instr? We call this safe to move.\nloop\n  = x\nx = a*b \n\nthe def must dom all the uses\nno other defs of the same variable\ndef dominates all the loop exits\n\n   loop {\n     if cond goto exit\n     x = a*b \n       = x\n   }\nFor cond 3\nif the loop runs zero times, a*b is never executed\nWe can remove this condition if the dest variable is dead after the loop or the instruction can cause a exception, this is called speculative exceptions.\nHow about an example:\n\n\n\n\n\n    graph TD;\nB1[\" B1:\n      1: b = 2\n      2: i = 1\"]\nB2[\"b2:\n   i &lt; 100\"]\nB3[\"B3:\n   3: a = b+1\n   4: c = 2\n   i mod 2 == 0\"]\nB4[\"b4: \n    5: d = a + d \n    6: e = 1 +d\"]\nB5[\"B5:\n    7: d= -c\n    8: f = 1+a\"]\nB6[\"B6:\n  9: i = i + 1\n     a &lt; 2\"]\nEntry --&gt; B1\nB1--&gt; B2\nB2 -- y --&gt;exit;\nB2 --n --&gt; B3\nB3 --y --&gt; B4\nB3 --n --&gt; B5\nB4--&gt; B6\nB5 --&gt; B6\nB6 --y --&gt; exit\nB6 --n --&gt; B2\n\n\n\n\n\n\n\nsteps:\n\ncreate pre header\nb2.1 not loop invar\nb3.1 loop inv\nb3.2 loop inv\nb3.3 not loop inv\nb4.1 not loop inv\nb4.2 not loop inv\nb5.1 not loop inv other def of d\nb5.2 loop invar\nb6.1 not loop inv\nb6.2 loop inv change = 2 repeat\n\n\n\n\n\n\n    graph TD;\nB1[\" B1:\n      1: b = 2\n      2: i = 1\"]\nB2[\"b2:\n   i &lt; 100\"]\nB3[\"B3:\n   i mod 2 == 0\"]\nB4[\"b4: \n    5: d = a + d \n    6: e = 1 +d\"]\nB5[\"B5:\n    7: d= -c\n\"]\nB6[\"B6:\n  9: i = i + 1\n     t\"]\npre[\"pre:\n   3: a = b+1\n      4: c = 2\n        8: f = 1+a\n        t = a &lt; 2\"]\nEntry --&gt; B1\nB1--&gt; pre\npre --&gt; B2\nB2 -- y --&gt;exit;\nB2 --n --&gt; B3\nB3 --y --&gt; B4\nB3 --n --&gt; B5\nB4--&gt; B6\nB5 --&gt; B6\nB6 --y --&gt; exit\nB6 --n --&gt; B2\n\n\n\n\n\n\n\nIf we forward propagate values we could find a = 3, f = 3, t = false, and since t is false there is no loop\nmoving the instructions out of the loop reduces the number of instructions which is good, but it also extends life times and therefore register pressure which is bad.\n\n\n\n Back to top",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "05 loop invariant code motion"
    ]
  },
  {
    "objectID": "lectures/14_gpu_compilers.html",
    "href": "lectures/14_gpu_compilers.html",
    "title": "14_gpu_compilers",
    "section": "",
    "text": "Warning\n\n\n\nnot done\n\n\n\n\n\n Back to top",
    "crumbs": [
      "EECS 7398",
      "Lectures",
      "14_gpu_compilers"
    ]
  }
]