This is a hands-on course about implementing optimizations in programming languages. 
It covers intermediate representations, classic optimization, runtime systems, and more advanced techniques such as parallelization,
 just-in-time compilation, and garbage collection. Course work consists of reading and discussing both classic and modern research 
 papers and implementation projects based on the modern compiler infrastructure.  Students will write blog posts describing their work.



This is a hands-on course about implementing machine independent transformations in programming languages. 
It covers intermediate representations, classic optimization, runtime systems, 
and more advanced techniques such as parallelization, just-in-time compilation, and garbage collection. 
Course work includes  reading and discussing both classic and modern research papers, 
coding transforms, and a class project.  Students will write blog posts describing their work.

 This is a course in compiler technology. First, it aims to develop a fundamental understanding of the major approaches to program analysis and optimization. 
 Second, it aims to help students understand published research on various novel compiler techniques.
Third, during the duration of the course, the students will solve a significant compiler problem, which includes reading the literature and implementing the solution in a real-world compiler, such as LLVM. Finally, the students will learn about recent research directions,


Course Objectives:
● Gain an understanding of compiler-based program analysis and transformations.
● Understand the importance of abstractions in the compilation flow.
● Explore published research in the area of compilers (e.g., CGO, PLDI).
● Develop practical skills in program analysis, optimization, and code generation
through hands-on exercises and projects.
● Enhance critical thinking abilities by analyzing and evaluating the strengths and
weaknesses of various compiler optimization techniques.
● Develop effective communication skills through project presentations,
discussions on research papers, and collaborative problem-solving activities.


Course goals:
After this course, students should be able to:
● Make use of LLVM and other compiler tools in research.
● Read and understand research papers that include compiler-related concepts.
● Implement program transformations that work at an intermediate representation
level.

The work consists of reading papers and programming homework tasks. Students will
use LLVM and Bril (an educational intermediate representation developed at Cornell
University). The course will require both programming and writing blog posts.


Presents major approaches to program analysis and optimization. Covers intermediate representations, classic optimizations, and more advanced techniques such 
as parallelization, just-in-time compilation, and garbage collection and the current state of the art.  Students will read, discuss and present 
 both classic and modern compiler research papers.
Students. There are programming homeworks and projects using  LLVM and Bril IR.  
After this course students should be able to write new compiler passes or modify existing ones.
The course will require discussions, programming,  and writing blog posts. Requires working knowledge of C/C++, python, algoritms and data structures. 



Presents state-of-the-art methods, tools, and techniques for system-level design and modeling of complete multiprocessor systems from specification down to implementation across
hardware-software boundaries. Recognizes that system complexities are growing exponentially, driven by ever-increasing application demands and technological advances that allow one 
to put complete multiprocessor systems on a chip (MPSoCs). System-level design that jointly covers hardware and software is one approach to address the associated complexities 
in the design process and the market pressures. Using system-level design languages (e.g., SpecC, SystemC), offers students an opportunity to specify, simulate, analyze, model,
 and design hardware-software systems based on examples of typical embedded applications. Requires working knowledge of C/C++, algorithms, and data structures.

 This course studies the construction of optimizing compilers with a focus on uniprocessor architectures. We will cover data-flow analysis, program optimization, and code generation across basic blocks, procedures, and complete programs. We will study classical topics such as dataflow analysis, static-single assignment, interprocedural and intraprocedural analysis, intermediate representations, register allocation, and scheduling in depth and in the context of modern uniprocessors. We will sample some of the key challenges for modern compilers and runtime systems: optimizations for object-oriented languages, just-in-time compilation, garbage collection, dependence analysis, and loop transformations (the later two are the building blocks for optimizing for memory hierarchies and parallel machines).

This course is experiential. The bulk of your course grade will come from programming assignments that implement program analysis, intermediate representations, and optimizations. You will write critiques of original research papers,
 which will teach you how to express technical thoughts clearly in your writing and will teach you critical thinking skills.



Presents essential  tools for understanding and transforming programs, 
covering  intermedicate representations, classic compiler optimizations, and  advanced techniques such 
as parallelization, just-in-time compilation, and polyhedral analysis. Students will engage with both foundational and contemporary 
research papers in compiler technology through readings, discussions, and presentations. The coursework includes programming assignments 
and projects that utilize LLVM and Bril IR to implement various compiler passes. Additionally, students will write blog posts to document 
and reflect on their readings, assignments, and projects. A working knowledge of C++, or Python, algorithms, and data structures is required.

Students will engage read, dissuss and present both classic and current compiler research papers
There are programming homeworks and projects using  LLVM and Bril IR to implement compiler passes. Students will write blog posts describing the readings, homeworks and projects.
R equires working knowledge of C/C++, python, algoritms and data structures. 



Presents essential tools for understanding and transforming programs, covering intermediate representations, classic compiler optimizations, 
and advanced techniques such as parallelization, just-in-time compilation, and polyhedral analysis. Students will engage with both foundational 
and contemporary research papers in compiler technology through readings, discussions, and presentations.The coursework includes programming assignments 
and projects that utilize LLVM and Bril IR to implement various compiler passes. Additionally, students will write blog posts to document and reflect on 
their readings, assignments, and projects. Proficiency in either C++ or Python, along with a strong understanding of algorithms and data structures, is required.