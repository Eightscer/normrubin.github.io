
sid\n    a: int = const 42;\n    print a;\n\n}\n\ncopy propagation\n\nmain{\n    x: int = const 4;\n    copy1: int = id x;\n    copy2: int = id copy1;\n    print copy2;\n}\n\ncommon sub-expression elimination cse \n\nmain {\n    a: int = const 4;\n    b: int = const 2;\n    sum1: int = add a b;\n    sum2: int = add a b;\n    prod: int = mul sum1 sum2;\n    print prod;\n}\n```\n\n\nWe want to stop thinking about varaibles and think about values.\nTwo instructions are redundant if they compute the same value.\n\n### this is a very deep idea that comes up multiple times.  \n\nfor example in a JIT compiler we want computation to be fast so we can get rid of all the variables\n```\nb: int const 1;\nc: int cont 2;\na:  int b c;  \n```\nbecomes:\n```\n[  int const 1\n   int const 2 \n   int 0 1\n]\n```\nless storage, args are just pointers, instructions are smaller.\nfaster because any use points to the corresponding def without any searching.\n\n\nPseudo code (similar to an interpreter)\n\nhash table \nconstants and expressions of value numbers to value numbers and a variable holding the value \n\nreverse map from variable to value numbers \n\n\n```\n  main {\n    a: int = const 4;\n    b: int = const 2;\n    sum1: int = add a b;\n    sum2: int = add a b;\n    prod: int = mult sum1 sum2;\n    print prod\n\n  }\n```\n\ntable \n\n|key | value  |canonical name|\n|---| ------| ------|\n|const 4 | 1 | a |\n|const 2 | 2 | b |\n|add 1 2 | 3 | sum1|\n|mul 3 3 | 4 | prod| \n\nrevese map\n\n| name | value|\n|---| ---|\n| a    | 1|\n| b    | 2 |\n| sum1 | 3|\n| sum2 | 3| \n| prod | 4 \n\n\nas we lookup each instruction - replace each arg with the canonical home\n\nif the value is already in the table replace with an id from canonical home\n\nextensions \n\n1) a: int id b \n\na gets the value number of b. No copy required\n\n2) : int add a b; for add sort value numbers so add a b; and add b a; get the same value number \n\n3) \n\n```\nconstant folding \n   a: int const 1;\n   b: int const 2;\n   c: add a b;\n```\nif both value numbers are pointing to constants- actually do the add\n\n\n### pseudo code\n\n ```\n    table = mapping from value tuples to canonical variables,\n      with each row numbered\n    var2num = mapping from variable names to their current\n      value numbers (i.e., rows in table)\n\n    for instr in block:\n        value = (instr.op, var2num[instr.args[0]], ...)\n\n        if value in table:\n            # The value has been computed before; reuse it.\n            num, var = table[value]\n            replace instr with copy of var\n\n        else:\n            # A newly computed value.\n            num = fresh value number\n\n            dest = instr.dest\n            if instr.dest  will be overwritten later:\n                 dest = fresh variable name\n                 instr.dest = dest\n            else:\n                 dest = instr.dest\n\n            table[value] = num, dest\n\n            for a in instr.args:\n                replace a with table[var2num[a]].var\n\n        var2num[instr.dest] = num\n```\n\nproblem:   canonical variables being overwritten\n\n``` x = a+b  \n    x = \n      = a+b \n\n```\n\n* Local value numbering.\n \n\n\n\nYou can see my implementation in `lvn.py` in [the examples directory] in the Bril repository. But seriously, don't be tempted! You want to write your implementation without looking at mine!\n\n[examples](https://github.com/sampsyo/bril/tree/main/examples)\n### Testing Your Optimizations\n\nAs part of your tasks for this lesson, you will implement your first two optimizations.\nThe two main things you want your optimizations to do are:\n\n1. Not break programs.\n2. Make programs faster, most of the time.\n\nAs with every task in this class, part of the work is checking that you have done what you set out to do---in this case, that your optimizations do those two things.\nThink carefully about how to make a convincing case for each of those criteria.\n\nOne tempting methodology might be to handwrite a few small test-case Bril programs (or, worse, borrow the woefully inadequate ones sitting around in the Bril git repository), run them through your optimizations, and look at them to check whether they look right.\nThis does not amount to convincing evidence (maybe you can think of a few specific reasons why).\n\nWhile there are many ways to be convincing, a pretty good way might be to run your optimization on *every single available [Bril benchmark][bench]*,\nsystematically check that it still produces the right output for at least one input,\nand collect aggregate statistics about some metric you're interested in.\nThis is a nice way to check for unexpected behavior in programs that you didn't carefully write yourself to test the cases you're thinking of.\n\nIf this is the route you choose, you can do it however you like, I have made a simple tool that you can consider using, called [Brench][].\nBrench is not very fancy; it does three things:\n\n1. It makes it easy to run a long list of inputs through several different commands. (For example, you can run a long list of Bril benchmarks through an \"interpret\" command and an \"optimize-and-then-interpret\" command.)\n2. It checks that all the commands agree on their output. (So, in our use case, it checks that optimizing the benchmark doesn't change its output when interpreted.)\n3. It can collect a statistic from each command for comparison. (Like the number of dynamic instructions the interpreter executed, which is a pretty good metric for standard optimizations.)\n\nThose three things are probably what you want to do to make a convincing case for an optimization's correctness and effectiveness, whether or not you use Brench. It's there if you want it, but feel free to go your own way!\n\n[bench]: https://capra.cs.cornell.edu/bril/tools/bench.html\n\n\n","srcMarkdownNoYaml":"\n\n### Local Value Numbering\n\nValue numbering is a very powerful technique that removes ***redunancies***,  An instruction  x + y is redundant inside a block if it has already been computed\nin the block, and no intervening operation redefines x or y. If the compiler\nfinds a redundant expression, it can save that value at the first computation\nand replace any subsequent evaluations with references to the saved value.\n\nThe idea is simple - The algorithm executes the block, Each time it sees a new variable it gives it a value (reprented as a number)\nEach time it sees an instruction it forms a hash of the op code and t he value numbers of its operands and gives tha a new value number.\n\nTwo instructions are redundant if they have same op code and operands, which means the same value number\n\ne_i and e_j have the\nsame value number if and only if e_i and e_j are provably equal for all possible\noperands of the expressions.\n\nlocal value numbering covers lot of optimizations\n\n```\ndead code elimination\n\nmain {\n    a: int = const 100;\n    a: int = const 42;\n    print a;\n\n}\n\ncopy propagation\n\nmain{\n    x: int = const 4;\n    copy1: int = id x;\n    copy2: int = id copy1;\n    print copy2;\n}\n\ncommon sub-expression elimination cse \n\nmain {\n    a: int = const 4;\n    b: int = const 2;\n    sum1: int = add a b;\n    sum2: int = add a b;\n    prod: int = mul sum1 sum2;\n    print prod;\n}\n```\n\n\nWe want to stop thinking about varaibles and think about values.\nTwo instructions are redundant if they compute the same value.\n\n### this is a very deep idea that comes up multiple times.  \n\nfor example in a JIT compiler we want computation to be fast so we can get rid of all the variables\n```\nb: int const 1;\nc: int cont 2;\na:  int b c;  \n```\nbecomes:\n```\n[  int const 1\n   int const 2 \n   int 0 1\n]\n```\nless storage, args are just pointers, instructions are smaller.\nfaster because any use points to the corresponding def without any searching.\n\n\nPseudo code (similar to an interpreter)\n\nhash table \nconstants and expressions of value numbers to value numbers and a variable holding the value \n\nreverse map from variable to value numbers \n\n\n```\n  main {\n    a: int = const 4;\n    b: int = const 2;\n    sum1: int = add a b;\n    sum2: int = add a b;\n    prod: int = mult sum1 sum2;\n    print prod\n\n  }\n```\n\ntable \n\n|key | value  |canonical name|\n|---| ------| ------|\n|const 4 | 1 | a |\n|const 2 | 2 | b |\n|add 1 2 | 3 | sum1|\n|mul 3 3 | 4 | prod| \n\nrevese map\n\n| name | value|\n|---| ---|\n| a    | 1|\n| b    | 2 |\n| sum1 | 3|\n| sum2 | 3| \n| prod | 4 \n\n\nas we lookup each instruction - replace each arg with the canonical home\n\nif the value is already in the table replace with an id from canonical home\n\nextensions \n\n1) a: int id b \n\na gets the value number of b. No copy required\n\n2) : int add a b; for add sort value numbers so add a b; and add b a; get the same value number \n\n3) \n\n```\nconstant folding \n   a: int const 1;\n   b: int const 2;\n   c: add a b;\n```\nif both value numbers are pointing to constants- actually do the add\n\n\n### pseudo code\n\n ```\n    table = mapping from value tuples to canonical variables,\n      with each row numbered\n    var2num = mapping from variable names to their current\n      value numbers (i.e., rows in table)\n\n    for instr in block:\n        value = (instr.op, var2num[instr.args[0]], ...)\n\n        if value in table:\n            # The value has been computed before; reuse it.\n            num, var = table[value]\n            replace instr with copy of var\n\n        else:\n            # A newly computed value.\n            num = fresh value number\n\n            dest = instr.dest\n            if instr.dest  will be overwritten later:\n                 dest = fresh variable name\n                 instr.dest = dest\n            else:\n                 dest = instr.dest\n\n            table[value] = num, dest\n\n            for a in instr.args:\n                replace a with table[var2num[a]].var\n\n        var2num[instr.dest] = num\n```\n\nproblem:   canonical variables being overwritten\n\n``` x = a+b  \n    x = \n      = a+b \n\n```\n\n* Local value numbering.\n \n\n\n\nYou can see my implementation in `lvn.py` in [the examples directory] in the Bril repository. But seriously, don't be tempted! You want to write your implementation without looking at mine!\n\n[examples](https://github.com/sampsyo/bril/tree/main/examples)\n### Testing Your Optimizations\n\nAs part of your tasks for this lesson, you will implement your first two optimizations.\nThe two main things you want your optimizations to do are:\n\n1. Not break programs.\n2. Make programs faster, most of the time.\n\nAs with every task in this class, part of the work is checking that you have done what you set out to do---in this case, that your optimizations do those two things.\nThink carefully about how to make a convincing case for each of those criteria.\n\nOne tempting methodology might be to handwrite a few small test-case Bril programs (or, worse, borrow the woefully inadequate ones sitting around in the Bril git repository), run them through your optimizations, and look at them to check whether they look right.\nThis does not amount to convincing evidence (maybe you can think of a few specific reasons why).\n\nWhile there are many ways to be convincing, a pretty good way might be to run your optimization on *every single available [Bril benchmark][bench]*,\nsystematically check that it still produces the right output for at least one input,\nand collect aggregate statistics about some metric you're interested in.\nThis is a nice way to check for unexpected behavior in programs that you didn't carefully write yourself to test the cases you're thinking of.\n\nIf this is the route you choose, you can do it however you like, I have made a simple tool that you can consider using, called [Brench][].\nBrench is not very fancy; it does three things:\n\n1. It makes it easy to run a long list of inputs through several different commands. (For example, you can run a long list of Bril benchmarks through an \"interpret\" command and an \"optimize-and-then-interpret\" command.)\n2. It checks that all the commands agree on their output. (So, in our use case, it checks that optimizing the benchmark doesn't change its output when interpreted.)\n3. It can collect a statistic from each command for comparison. (Like the number of dynamic instructions the interpreter executed, which is a pretty good metric for standard optimizations.)\n\nThose three things are probably what you want to do to make a convincing case for an optimization's correctness and effectiveness, whether or not you use Brench. It's there if you want it, but feel free to go your own way!\n\n[bench]: https://capra.cs.cornell.edu/bril/tools/bench.html\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"03b_local_value_numbering.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.554","title":"_ local value numbering"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
