{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"2 Representation of programs\"\n",
        "format: \n",
        "    html: default\n",
        "    revealjs:\n",
        "        chalkboard: true\n",
        "        output-file: revealjs-rep\n",
        "keep-ipynb: true\n",
        "python: kaggle_comp\n",
        "sidebar: false\n",
        "---\n",
        "\n",
        " \n",
        "## How do we represent programs \n",
        "\n",
        "The representation of a program\n",
        "\n",
        "What we read in and read out when transforming a program.\n",
        "\n",
        "What kind of properties make a good representation?\n",
        "\n",
        "\n",
        "::: {.content-hidden  when-format=\"revealjs\"}\n"
      ],
      "id": "3875f0f6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from graphviz import Digraph\n",
        "import ast\n",
        "import os \n",
        "\n",
        "def cmd(x):\n",
        "  os.system(x)\n",
        "  \n",
        "def ast_syntax(line):\n",
        "  return ast.dump(ast.parse(line).body[0], indent=4)\n",
        "\n",
        "  \n",
        "# Define a function to recursively add nodes to the Digraph\n",
        "def add_node(dot, node, parent=None):\n",
        "  node_name = str(node.__class__.__name__)\n",
        "  dot.node(str(id(node)), node_name)\n",
        "  if parent:\n",
        "    dot.edge(str(id(parent)), str(id(node)))\n",
        "  for child in ast.iter_child_nodes(node):\n",
        "    add_node(dot, child, node)\n",
        "\n",
        "# Add nodes to the Digraph\n",
        "\n",
        "def graph(line):\n",
        "  dot = Digraph()\n",
        "  add_node(dot, ast.parse(line).body[0])\n",
        "  return dot"
      ],
      "id": "8427dbc4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## Concrete Syntax \n",
        "\n",
        "One possible representation is called ***concrete syntax form*** \n",
        "Programs are text or surface syntax- just what you would type into an editor.\n",
        "\n",
        "```\n",
        "value = 8\n",
        "result = 1\n",
        "for i in range(value):\n",
        "  result = result + i\n",
        "print(result)\n",
        "```\n",
        "\n",
        "What is good and what is bad about this representation?\n",
        "\n",
        "What is the level of abstraction?\n",
        "\n",
        "How do you understand the semantics.\n",
        "\n",
        "##  Abstract syntax\n",
        "\n",
        "Tree structure\n",
        "\n",
        "1. Nodes are parts of the program, \n",
        "2. Edges show how they are connected.\n",
        "\n",
        "We can write this as a list or a graph\n",
        "\n",
        "::: {.columns}\n",
        "\n",
        "::: {.column}\n",
        "\n",
        "```\n",
        "def pgm():\n",
        "    value = 8\n",
        "    result = 1\n",
        "    for i in range(value):\n",
        "        result = result * i\n",
        "    print(result)\n",
        "```\n",
        ":::\n",
        "\n",
        "::: {.column}\n",
        "\n",
        "![](images/abst.png)\n",
        "\n",
        ":::\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "----\n",
        "\n",
        "\n",
        "## AST tree representation\n",
        "\n",
        "An AST is a tree structure, nodes like 'if', 'test', 'body', assign'.\n",
        "\n",
        "Each node is one concept from the program \n",
        " \n",
        "Recursive function can walk over the tree,  one chunk of code for each node. \n",
        "\n",
        "1. Good - each type of node is different, making special cases are easy\n",
        "1. Bad  - each type of node is different so analysis has to know about every type, making general cases hard  \n",
        " \n",
        "This is the classic way to write an interpreter.\n",
        "\n",
        "Simple (non optimizing) compilers often use this format.\n",
        "\n",
        "---\n",
        "\n",
        "##  A more regular representation\n",
        "\n",
        "Programs are lists of instructions. Like an assembly instructions. Same sort of representation as LLVM.\n",
        "\n",
        " ***ts2bril images/toy.ts | bril2txt***\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "\n",
        "::: {.column width=\"45%\"}\n",
        "```\n",
        "    //typescript program \n",
        "    let value = 8\n",
        "    let result = 1\n",
        "    for (let i = 0; i < value;\n",
        "         i = i+1)\n",
        "    {\n",
        "        result = result * i\n",
        "    }\n",
        "    console.log(result )\n",
        "```\n",
        "\n",
        ":::\n",
        "\n",
        "::: {.column width=\"5%\"}\n",
        "<!-- empty column to create gap -->\n",
        ":::\n",
        "\n",
        "::: {.column width=\"40%\"}\n",
        "```\n",
        "@main {\n",
        "  v0: float = const 8;\n",
        "  value: float = id v0;\n",
        "  v1: float = const 1;\n",
        "  result: float = id v1;\n",
        "  v3: float = const 0;\n",
        "  i: float = id v3;\n",
        ".for.cond.2:\n",
        "  v4: float = id i;\n",
        "  v5: float = id value;\n",
        "  v6: bool = flt v4 v5;\n",
        "  br v6 .for.body.2 .for.end.2;\n",
        ".for.body.2:\n",
        "  v7: float = id result;\n",
        "  v8: float = id i;\n",
        "  v9: float = fmul v7 v8;\n",
        "  result: float = id v9;\n",
        "  v10: float = id i;\n",
        "  v11: float = const 1;\n",
        "  v12: float = fadd v10 v11;\n",
        "  i: float = id v12;\n",
        "  jmp .for.cond.2;\n",
        ".for.end.2:\n",
        "  v13: float = id result;\n",
        "  print v13;\n",
        "  v14: int = const 0;\n",
        "}\n",
        "\n",
        "```\n",
        "\n",
        ":::\n",
        "\n",
        "::::\n",
        "\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "## bril\n",
        "\n",
        "1. Looks like assembly \n",
        "\n",
        "1. no limit on registers, \n",
        "\n",
        "1. no condition codes. \n",
        "\n",
        "1. fully typed, \n",
        "\n",
        "1. no complex addressing modes.\n",
        "\n",
        "1. easy to extend \n",
        "\n",
        "\n",
        "## Bril syntax\n",
        "\n",
        "Declare functions, labels, instructions \n",
        " \n",
        "instruction:  \n",
        "\n",
        "1. variable type = opcode arguments \n",
        "1. opcode list of arguments \n",
        "\n",
        "Form 1, variable is the destination, like a: int = add b, c\n",
        "\n",
        "Form 2, no destination, like print a \n",
        "\n",
        "what is good and what is about this representation?\n",
        "\n",
        " \n",
        "# Using Bril - Control Flow Graph\n",
        "\n",
        "extract info from this representation. \n",
        "\n",
        "##  control flow graph (CFG) (version 1)\n",
        " \n",
        "Representation is a directed graph. \n",
        "\n",
        "1. Nodes are instructions, \n",
        "2. edges indicate ***possible*** flow of control, \n",
        "3. one entry and one exit node.\n",
        " \n",
        "---\n",
        "\n",
        "##  Example one \n",
        "\n",
        "\n",
        "\n",
        "```{bril}\n",
        "@main {\n",
        "    v: int = const 5;\n",
        "    print v;\n",
        "}\n",
        "```\n",
        "\n",
        "\n",
        ". . . \n",
        "\n",
        "\n",
        "\n",
        "```{mermaid}\n",
        "%%| fig-width: 10\n",
        "%%| fig-height: 9\n",
        "\n",
        "flowchart LR\n",
        "A[const] --> B[print]\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "---\n",
        "\n",
        "## second example \n",
        "\n",
        "\n",
        " ```\n",
        "     @main {\n",
        "         v: int = const 4;\n",
        "         jmp  .somewhere;\n",
        "         v: int = const 2;\n",
        "         .somewhere;\n",
        "         print v;\n",
        "     }\n",
        " ```\n",
        "\n",
        ". . .\n",
        "\n",
        "\n",
        "\n",
        "```{mermaid}\n",
        "%%| fig-width: 6.5\n",
        "flowchart LR\n",
        "  A[const 4] --> B[jmp]\n",
        "  B --> C[print]\n",
        "  D[const 2] --> C\n",
        "```\n",
        "\n",
        "\n",
        ". . . \n",
        "\n",
        "notice label does not produce a node\n",
        "\n",
        "Easy to see a dead instruction.   \n",
        "\n",
        "---\n",
        "\n",
        "## Third example:\n",
        "\n",
        "\n",
        "```\n",
        "    @main {\n",
        "        v: int = const 4;\n",
        "        b: bool = const false;\n",
        "        br b .there .here;\n",
        "    .here:\n",
        "        v: int = const 2;\n",
        "    .there;\n",
        "        print v;\n",
        "    }\n",
        "```\n",
        "\n",
        ". . .\n",
        "\n",
        "\n",
        "\n",
        "```{mermaid}\n",
        "%%| fig-width: 6.5\n",
        "flowchart LR\n",
        "  A[v: int const 4] --> B[b: bool const false]\n",
        "  B --> C[br b .there, .false]\n",
        "  C --> D[v: const 2]\n",
        "  C --> E[print v]\n",
        "  D --> E\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        ". . . \n",
        "\n",
        "which is the true edge and which is the false edge , could mark the edges or use a convention\n",
        "\n",
        "Which is the entry, which is the exit?\n",
        "\n",
        "\n",
        "There is a long chain of instructions entered at the top, exit at the bottom, no branches inside. \n",
        "\n",
        "## CFG (cfg form 2)\n",
        "\n",
        "1) nodes ares  sequences of instructions. \n",
        "1) jumps and branches can only be at the end of a sequence\n",
        "1) only label has to be at the start \n",
        "1) every instruction in the sequence executes the same number of times\n",
        "\n",
        "---\n",
        " \n",
        "## construct cfg \n",
        "\n",
        " walk over the instructions:\n",
        "\n",
        "As we construct basic blocks, we can add instructions up till something that ends the block (***terminator***)\n",
        "\n",
        "\n",
        "Option: do all blocks end in a terminator or not?\n",
        "\n",
        "given a block b, the ***predecessors*** of $b$ are the blocks $b_{in}$ where there is an edge $b_{in}->b$.\n",
        "And the ***successors*** of $b$ are the $b_{out}$ where $b->b_{out}$ is an edge. \n",
        "\n",
        "\n",
        "\n",
        "## What is an algorithm that forms a cfg \n",
        "\n",
        ". . .\n",
        "\n",
        "1) just find all the basic blocks \n",
        "1) add the control flow edges \n",
        "\n",
        "## pseudo code to construct cfg \n",
        "\n",
        "1. in: instructions - list of instructions\n",
        "1. out blocks - list of lists of instructions \n",
        "```\n",
        "current_block = []\n",
        "for i in instructions:\n",
        "    if i is not a label:\n",
        "       block.append(i)\n",
        "    if i is a label or terminator:\n",
        "        blocks.append(current_block)\n",
        "        current_block = []\n",
        "``` \n",
        "\n",
        "---\n",
        "\n",
        "step 2 \n",
        "  we need a map from labels to basic blocks \n",
        "\n",
        "\n",
        "1) in: instructions - list of instructions\n",
        "2) out blocks - list of lists of instructions \n",
        "```\n",
        "current_block = []\n",
        "for i in instructions:\n",
        "    if i is not a label:\n",
        "       block.append(i)\n",
        "    if i is a label or terminator:\n",
        "        blocks.append(current_block)\n",
        "        current_block = []\n",
        "    \n",
        "\n",
        "for block in blocks:\n",
        "   last = block[-1]\n",
        "   if last is a jmp (one successor)\n",
        "      add edge from block to last.dest \n",
        "   else if last is a br (two successors)\n",
        "      add two edges from block to last.true, last.false \n",
        "   else  fall through \n",
        "      add edge to next block (if it exists)\n",
        "```\n",
        "\n",
        "## How to look at a Bril program \n",
        "\n",
        "::: {.content-visible}"
      ],
      "id": "5b53c775"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "with open(\"images/add.json\", 'r') as f:\n",
        "  bril_program = f.read()\n",
        "  print(bril_program)"
      ],
      "id": "4d4e6d85",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n"
      ],
      "id": "901ad424"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/norm/miniforge3/envs/kaggle_comp/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}